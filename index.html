<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>'Wild Cats' 13K Game 2025</title>
    <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="55%" x="50%" dominant-baseline="middle" text-anchor="middle" font-size="80">üêà‚Äç‚¨õ</text></svg>'>
    <style>
        /* Basic styles to make the canvas and joysticks fill the screen */
        html, body {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }
    </style>
</head>
<body>
    <!-- The main canvas for WebGL rendering -->
    <!-- <canvas id="C"></canvas> -->
    <canvas id="canvas"></canvas>

    <!-- HTML elements for the virtual joysticks -->
    
    <script>
    // -- FEATURE: Core --
    // Expose Math functions to global scope
    Object.getOwnPropertyNames(Math).forEach(n => window[n.toUpperCase()] = Math[n]);
    // --- Math Library ---
    const D2R = 0.0174532925 // or Math.PI / 180;
    const F32 = Float32Array;
    const M4 = (v) => new F32(v || [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
    const V3 = (v) => new F32(v || 3);
    const T_V3_A = V3(), T_V3_B = V3(), T_V3_C = V3(); // Reusable temporary V3s
    const T_V4_A = V3(4), T_V4_B = V3(4); // Reusable temporary V4s
    const T_V3_RAY_O = V3(), T_V3_RAY_D = V3(); // For raycasting results (Origin, Direction)
    const SUB=(t,n,r)=>(t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t);
    const DOT=(t,n)=>t[0]*n[0]+t[1]*n[1]+t[2]*n[2];
    const CROSS=(t,n,r)=>(t[0]=n[1]*r[2]-n[2]*r[1],t[1]=n[2]*r[0]-n[0]*r[2],t[2]=n[0]*r[1]-n[1]*r[0],t);
    const LEN=(t)=>HYPOT(t[0],t[1],t[2]);
    const NORM=(t,n)=>{var r=LEN(n);return r>0&&(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r),t};
    const MULTMAT4 = (o, a, b) => (o.set((new DOMMatrix(a)).multiply(new DOMMatrix(b)).toFloat32Array()), o);
    const INV = (m) => (new DOMMatrix(m)).inverse().toFloat32Array();
    const PERSP = (o, f, a, n, fa) => { const t = 1 / TAN(f * D2R / 2); o.set([t/a,0,0,0, 0,t,0,0, 0,0,(fa+n)/(n-fa),-1, 0,0,(2*fa*n)/(n-fa),0]); return o; };
    const LOOKAT = (o, e, c, u) => { SUB(T_V3_A,e,c); NORM(T_V3_A,T_V3_A); CROSS(T_V3_B,u,T_V3_A); NORM(T_V3_B,T_V3_B); CROSS(T_V3_C,T_V3_A,T_V3_B); o.set([T_V3_B[0],T_V3_C[0],T_V3_A[0],0, T_V3_B[1],T_V3_C[1],T_V3_A[1],0, T_V3_B[2],T_V3_C[2],T_V3_A[2],0, -DOT(T_V3_B,e),-DOT(T_V3_C,e),-DOT(T_V3_A,e),1]); return o; };
    // --- World Matrices ---
    const M = M4(), V = M4(), P = M4(); // Model, View, Projection
    let PV = M4(), invPV = M4(); // Combined and inverse matrices for picking

    // Multiplies a 3D point (w=1) by a 4x4 matrix
    function mulPoint(m, p) { const x=p[0],y=p[1],z=p[2],w=1; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    // Multiplies a 3D direction (w=0) by a 4x4 matrix
    function mulDir(m, d) { const x=d[0],y=d[1],z=d[2],w=0; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    function mul4(m, v) { return [m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3], m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3], m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3], m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3]]; }

    // Creates a translation and scale matrix
    function translateScale(x,y,z,sx,sy,sz) { return new F32([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, x,y,z,1]); }

    // const D = document
    // const C = D.getElementById('canvas');
    const canvas = document.getElementById('canvas');
    
   // State variables for the user/camera, rendering loop, and WebGL/WebXR contexts
    let user = { x: 0, y: 1.6, z: 2, yaw: 0, pitch: 0 }; // User position and orientation
    let last = 0; // Timestamp of the last frame for calculating delta time
    let gl, xr = null, ref = null, off = null; // WebGL and WebXR objects

    gl = canvas.getContext('webgl2', { antialias: true, xrCompatible: true });
    if (!gl) { alert('WebGL2 is required for this application.'); }

    // Resize the canvas to fill the window, accounting for device pixel ratio
    function resize() {
        const w = innerWidth, h = innerHeight, dpr = devicePixelRatio || 1;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
    }
    addEventListener('resize', resize);
    resize(); // Initial resize

    // Helper function to compile and link a shader program
    function prog(vs, fs) {
        const p = gl.createProgram();
        const v = gl.createShader(gl.VERTEX_SHADER);
        const f = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(v, vs); gl.compileShader(v);
        if (!gl.getShaderParameter(v, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(v);
        gl.shaderSource(f, fs); gl.compileShader(f);
        if (!gl.getShaderParameter(f, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(f);
        gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
        return p;
    }
    // -- /FEATURE: Core --

    // -- FEATURE: Input --
    // -- MODULE: Input-Core --
    // --- Unified Input Handling ---
    // Unified input state object for keyboard, joysticks, pointer-look, and pointer coordinates
    const input = {
        keys: {},
        joy: { left: { x: 0, y: 0, id: null }, right: { x: 0, y: 0, id: null } }, // 
        look: { id: null, x: 0, y: 0 },
        pointer: { x: 0, y: 0 }
    };
    const DZ = 0.1;    // Deadzone for joystick/gamepad axes to prevent drift
    // A map to track the previous pressed state of VR controller buttons for edge detection (press/release)
    const pressedMap = new Map();

    // State for the raycast
    let lastHit = null;
    // -- /MODULE: Input-Core --
    
    // -- MODULE: Input-KeyPoint --
    // Keyboard event listeners for movement and HUD toggle
    document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        input.keys[k] = true;
        if (k === 'h' || k === 'escape') {playClickSound(); hudVisible = !hudVisible;} // 'H' and escape key toggles HUD visibility
        if (k === 'f') {playClickSound(); beastMode = !beastMode;} // 'F' key toggles beastMode
    });
    document.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
    
    // Pointer event listeners on the canvas for mouse-look and interaction
    canvas.addEventListener('pointerdown', e => {
        initAudio(); // NEW: Initialize audio on first user interaction
        // Start mouse-look on left-click
        if (e.button === 0 && input.look.id === null) {
            input.look.id = e.pointerId;
            input.look.x = e.clientX;
            input.look.y = e.clientY;
            canvas.setPointerCapture(e.pointerId); // Lock the pointer to the canvas
        }
        // Always update pointer position for picking
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
    });
    
    canvas.addEventListener('pointermove', e => {
        // Update pointer position for hover effects
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
        
        // If we are in mouse-look mode, update camera orientation
        if (e.pointerId === input.look.id) {
            const dx = e.clientX - input.look.x;
            const dy = e.clientY - input.look.y;
            input.look.x = e.clientX;
            input.look.y = e.clientY;
            user.yaw += dx * 0.002;
            user.pitch = MAX(-PI / 2, MIN(PI / 2, user.pitch - dy * 0.002));
        }
    });
    
    canvas.addEventListener('pointerup', e => {
        // Stop mouse-look mode.
        if (e.pointerId === input.look.id) {
            input.look.id = null;
        }
        // Update pointer position and trigger an interaction check
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
    });
    
    canvas.addEventListener('pointercancel', e => {
        if (e.pointerId === input.look.id) {
            input.look.id = null;
        }
    });
    // -- /MODULE: Input-KeyPoint --
    
    // -- MODULE: Input-Joystick --
    // --- Virtual Joysticks for Touch Devices ---
    // -- /MODULE:Input-Joystick --
    // -- MODULE: Input-Ray --
    // -- /MODULE: Input-Ray --
    // -- /FEATURE: Input --

    // -- FEATURE: Gameplay --
    let beastMode = false; // toggle beast mode
    // -- MODULE: Gameplay-Movement --
    // --- Movement Logic ---
    // Movement and input constants
    const MOVES = 3;    // Movement speed in meters per second
    const TURNS = 2;    // Turning speed in radians per second

    // Consolidates input from keyboard, joysticks, and VR controllers into a single movement vector
    function getMove(session) {
        let vx = 0, vy = 0, vt = 0;
        // -- SOLUTION: Gameplay-Movement-Keyboard --
        // Keyboard input (WASD for move, QE for turn)
        const kx = (+!!input.keys.d) - (+!!input.keys.a);
        const ky = (+!!input.keys.w) - (+!!input.keys.s);
        const kt = (+!!input.keys.q) - (+!!input.keys.e);
        // -- /SOLUTION: Gameplay-Movement-Keyboard --
    
        // -- SOLUTION: Gameplay-Movement-Joystick --
        // -- /SOLUTION: Gameplay-Movement-Joystick --

        // -- SOLUTION: Gameplay-Movement-VR --
        // -- /SOLUTION: Gameplay-Movement-VR --

        // Return combined movement, prioritizing VR, then keyboard, then joystick
        return { x: vx || kx, y: vy || ky, t: vt || kt};
    }

    // -- SOLUTION: Gameplay-Movement-Step --
    // Updates the user's position and orientation based on movement input and delta time
    function step(dt, mv) {
        const now = performance.now();
        const moveMagnitude = Math.hypot(mv.x, mv.y);
        if(moveMagnitude > 0.1 && now - lastStepTime > stepInterval){
            playStepSound();
            lastStepTime = now;
        }
        user.yaw += mv.t * TURNS * dt; // Apply turning
        
        // Calculate forward and right vectors based on current yaw
        const cy = COS(user.yaw);
        const sy = SIN(user.yaw);
        T_V3_A[0] = -sy; T_V3_A[1] = 0; T_V3_A[2] = -cy; // 'f' vector
        T_V3_B[0] = cy;  T_V3_B[1] = 0; T_V3_B[2] = -sy;  // 'r' vector
        const sp = MOVES * dt;
        
        // Apply movement along forward and right vectors
        user.x += (T_V3_B[0] * mv.x + T_V3_A[0] * mv.y) * sp;
        user.z += (T_V3_B[2] * mv.x + T_V3_A[2] * mv.y) * sp;
    }
    // -- /SOLUTION: Gameplay-Movement-Step --
    // -- /MODULE: Gameplay-Movement --
    // -- /FEATURE: Gameplay --
    
    // -- FEATURE: Scene --
    // -- MODULE: Scene-Audio --
    // todo: implement stereo sources to get spatial audio (directional wind sound)
    let audioCtx = null;
    let lastStepTime = 0;
    const stepInterval = 500; // ms between walking sounds
    
    function initAudio(){
    }
    // -- SOLUTION: Scene-Audio-Wind --
    function playWindSound(){}
    // -- /SOLUTION: Scene-Audio-Wind --
    // -- SOLUTION: Scene-Audio-Click --
    function playClickSound(){}
    // -- /SOLUTION: Scene-Audio-Click --
    // -- SOLUTION: Scene-Audio-Step --
    function playStepSound(){}
    // -- /SOLUTION: Scene-Audio-Step --
    // -- /MODULE: Scene-Audio --

    // -- MODULE: Scene-HUD --
    // -- /MODULE: Scene-HUD --
    // -- MODULE: Scene-Sky --
    
    // -- /MODULE: Scene-Sky --
    // -- MODULE: Scene-Ground --
    // --- Grid Shader ---
    // A simple shader to draw a grid on the ground plane
    const vsG = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 p;
    uniform mat4 M, V, P;
    out vec3 w; // Pass world position to fragment shader.
    void main(){
        w = (M * vec4(p, 1.0)).xyz;
        gl_Position = P * V * vec4(w, 1.0);
    }`;
    const fsG = `#version 300 es
    precision highp float;
    in vec3 w;
    out vec4 o;
    void main(){
        float c = 2.0; // Grid cell size.
        // Draw lines using fract() and step().
        float l = step(abs(fract(w.x/c) - 0.5), 0.01) + step(abs(fract(w.z/c) - 0.5), 0.01);
        float g = clamp(l, 0.0, 1.0);
        // Fade to a darker color in the distance.
        vec3 b = mix(vec3(0.04), vec3(0.08), smoothstep(0.0, 20.0, length(w.xz)));
        o = vec4(b + g * vec3(0.2, 1.0, 0.2) * 0.6, 1.0);
    }`;

    const PG = prog(vsG, fsG);
    const uM = gl.getUniformLocation(PG, 'M');
    const uV = gl.getUniformLocation(PG, 'V');
    const uP = gl.getUniformLocation(PG, 'P');
    const vbo = gl.createBuffer();
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    // A large quad to serve as the ground plane.
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1e3,0,-1e3, 1e3,0,-1e3, 1e3,0,1e3, -1e3,0,-1e3, 1e3,0,1e3, -1e3,0,1e3]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    // -- /MODULE: Scene-Ground --
    // -- MODULE: Scene-Grass --
    
    // -- /MODULE: Scene-Grass --
    // -- MODULE: Scene-Plant --
    // --- L-System Plant Shader ---
    // -- SOLUTION: Scene-Plant--
    // Positions and scales for the scattered L-system plants.
    // --- Procedural plant field (infinite-style) ---
    const PLANT_CELL = 6.0;          // World size of one plant decision cell
    const PLANT_PROB = 0.3;         // Spawn probability per cell
    const PLANT_RADIUS = 55.0;       // Active radius around camera (render window)
    const PLANT_SCALE_MIN = 1.8;
    const PLANT_SCALE_MAX = 3.0;
    
    // Fast small hash (deterministic)
    function plantHash(ix, iz, salt){
        const s = Math.sin(ix*127.1 + iz*311.7 + salt*17.17)*43758.5453;
        return s - Math.floor(s);
    }
    
    // Generate plants near (cx,cz); returns array of objects
    function genPlants(cx, cz){
        const r = PLANT_RADIUS;
        const c = PLANT_CELL;
        const minX = Math.floor((cx - r)/c);
        const maxX = Math.floor((cx + r)/c);
        const minZ = Math.floor((cz - r)/c);
        const maxZ = Math.floor((cz + r)/c);
        const out = [];
        for(let gz=minZ; gz<=maxZ; gz++){
            for(let gx=minX; gx<=maxX; gx++){
                const h = plantHash(gx, gz, 0.0);
                if(h < PLANT_PROB){
                    // Stable jitter inside cell
                    const jx = plantHash(gx, gz, 1.0) - 0.5;
                    const jz = plantHash(gx, gz, 2.0) - 0.5;
                    const px = gx*c + (jx * c * 0.85) + c*0.5;
                    const pz = gz*c + (jz * c * 0.85) + c*0.5;
                    const dx = px - cx, dz = pz - cz;
                    if(dx*dx + dz*dz <= r*r){
                        const sc = PLANT_SCALE_MIN + (plantHash(gx, gz, 3.0) * (PLANT_SCALE_MAX - PLANT_SCALE_MIN));
                        out.push({px, pz, scale: sc, gx, gz});
                    }
                }
            }
        }
        return out;
    }
    
    const vsPlants = `#version 300 es
    precision highp float; // Use high precision for all float operations
    layout(location=0) in vec3 p; // Input vertex position attribute at location 0
    layout(location=1) in vec2 uv_in; // Input UV texture coordinate attribute at location 1
    uniform mat4 M, V, P; // Model, View, and Projection matrices
    out vec2 uv; // Pass UV coordinates to fragment shader
    void main() { // Main vertex shader function
        uv = uv_in; // Pass through UV coordinates unchanged
        gl_Position = P * V * M * vec4(p, 1.0); // Transform vertex position to clip space
    }`;

    const fsPlants = `#version 300 es
    precision highp float; // Use high precision for all float operations
    in vec2 uv; // UV coordinates received from vertex shader
    out vec4 o; // Output color for this fragment
    uniform float uTime; // Time uniform for animation
    uniform int uMaxIterations; // Control the quality/complexity
    uniform vec3 uPlantPos; // World position of the plant
    uniform float uPlantSeed; // Seed for this plant

    #define PI 3.14159 // Define PI constant for mathematical calculations

    mat3 Rot(float angle) { float c = cos(angle); float s = sin(angle); return mat3(vec3(c, s, 0), vec3(-s, c, 0), vec3(0, 0, 1)); }
    mat3 Disp(vec2 displacement) { return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(displacement, 1)); }

    float sdCappedCylinder(vec2 p, vec2 h) {
        p -= vec2(0., h.y);
        vec2 d = abs(vec2(length(p.x), p.y)) - h;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
    }

    // small hash helper inside shader
    float hashf(float x){ return fract(sin(x)*43758.5453); }
    float hash2(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }

    float center(vec2 pt) {
        float baseAngle = 25.7 + uPlantSeed * 10.0;
        mat3 posR = Rot(-(baseAngle / 360.) * 2. * PI);
        mat3 negR = Rot(baseAngle / 360. * 2. * PI);

        // Vary depth using seed (3..7)
        int depth = 3 + int(uPlantSeed * 4.0);
        const int branches = 3;
        int maxDepth = 1; for(int i=0;i<depth;i++) maxDepth *= branches;
        float len = 1.5;
        float wid = .02;
        pt = pt + vec2(0, 2);
        float trunk = sdCappedCylinder(pt - vec2(0., 0.), vec2(wid, len));
        float d = 500.;
        int c = 0;

        // Wind like grass
        vec2 w1 = vec2(0.07, 0.05);
        vec2 w2 = vec2(-0.03, 0.04);
        float gust = 0.6 * sin(dot(uPlantPos.xz, w1) + uTime * 0.7) + 0.4 * sin(dot(uPlantPos.xz, w2) - uTime * 1.2);
        float ph = fract(sin(dot(uPlantPos.xz, vec2(12.9898,78.233))) * 43758.5453) * 6.283;
        float sway = (0.25 * gust) + 0.07 * sin(uTime * 1.7 + ph);
        mat3 windMatrix = Rot(sway * 0.5);

        for (int count = 0; count <  uMaxIterations; ++count) {
            int off = 1; for(int i=0;i<depth;i++) off *= branches;
            vec2 pt_n = pt;
            for (int i = 1; i <= depth; ++i) {
                float l = len / pow(2., float(i));
                off /= branches;
                int dec = c / off;
                int path = dec - branches * (dec / branches);
                mat3 mx;
                if (path == 0) {
                    mx = posR * Disp(vec2(0, -2. * l));
                } else if (path == 1) {
                    mx = windMatrix * negR * Disp(vec2(0, -2. * l));
                } else {
                    mx = windMatrix * Disp(vec2(0, -4. * l));
                }
                pt_n = (mx * vec3(pt_n, 1)).xy;
                float y = sdCappedCylinder(pt_n, vec2(wid, l));
                if (y - 2.0 * l > 0.0) { c += off - 1; break; }
                d = min(d, y);
            }
            ++c;
            if (c > maxDepth) break;
        }
        return min(d, trunk);
    }

    void main() {
        // compute distance field
        vec2 p = (uv * 2.0 - 1.0) * 5.0;
        p.y += 3.0;
        float d = center(p);

        // alpha from distance (same approach as before)
        float t = clamp(d, 0.0, .04) * 2. * 12.5;
        float alpha = 1.0 - t;
        if (alpha < 0.05) discard;

        // vertical gradient factor from vertex UV (0..1)
        float height = clamp(uv.y, 0.0, 1.0);

        // base green and orange palettes
        vec3 green = vec3(0.3, 0.4, 0.1);
        vec3 orange = vec3(0.5, 0.4, 0.2);

        // random tint 0..1 from seed -> bias towards green or orange
        float tint = hashf(uPlantSeed * 37.17);

        // per-plant subtle brightness variation
        float varb = 0.85 + 0.3 * hash2(uPlantPos.xz + vec2(uPlantSeed));

        // mix base color between green and orange, then apply vertical gradient
        vec3 base = mix(green, orange, smoothstep(0.0, 1.0, tint));
        vec3 top = base * 1.;
        vec3 bottom = base * 0.4;
        vec3 col = mix(bottom, top, smoothstep(0.0, 1.0, height)) * varb;

        // slight per-pixel noise to avoid banding
        float n = hash2(uPlantPos.xz + uv*12.34);
        col *= (0.97 + 0.06 * n);

        o = vec4(col * alpha, alpha);
    }`;

    const PPLANTS = prog(vsPlants, fsPlants); // Compile and link plant shader program
    const uMPla = gl.getUniformLocation(PPLANTS, 'M'); // Get location of Model matrix uniform
    const uVPla = gl.getUniformLocation(PPLANTS, 'V'); // Get location of View matrix uniform
    const uPPla = gl.getUniformLocation(PPLANTS, 'P'); // Get location of Projection matrix uniform
    const uTimePla = gl.getUniformLocation(PPLANTS, 'uTime'); // Get location of time uniform for animation
    const uMaxIterationsPla = gl.getUniformLocation(PPLANTS, 'uMaxIterations'); // Get location of max iterations uniform
    const uPlantPosPla = gl.getUniformLocation(PPLANTS, 'uPlantPos');
    const uPlantSeedPla = gl.getUniformLocation(PPLANTS, 'uPlantSeed');

    const vboPlants = gl.createBuffer(), vaoPlants = gl.createVertexArray(); // Create vertex buffer and vertex array objects
    gl.bindVertexArray(vaoPlants); // Bind the vertex array object
    gl.bindBuffer(gl.ARRAY_BUFFER, vboPlants); // Bind the vertex buffer object
    // Vertex data for a quad (position and UV coordinates).
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1,2,0, 0,1,  1,2,0, 1,1,  1,0,0, 1,0,  -1,2,0, 0,1,  1,0,0, 1,0,  -1,0,0, 0,0]), gl.STATIC_DRAW); // Upload vertex data: 6 vertices forming 2 triangles for a quad, each with position (x,y,z) and UV (u,v)
    gl.enableVertexAttribArray(0); // Enable vertex attribute array at location 0 (position)
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 20, 0); // Set vertex attribute pointer for position: 3 floats, stride 20 bytes, offset 0
    gl.enableVertexAttribArray(1); // Enable vertex attribute array at location 1 (UV)
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 20, 12); // Set vertex attribute pointer for UV: 2 floats, stride 20 bytes, offset 12 bytes
    // -- /SOLUTION: Scene-Plant--
    // -- SOLUTION: Scene-Plant1--
    // -- /SOLUTION: Scene-Plant1--
    // -- /MODULE: Scene-Plant --
    
    // -- MODULE: Scene-Reticle --
    
    // -- /MODULE: Scene-Reticle --

    // -- MODULE: Scene-VR --
    // -- /MODULE: Scene-VR --

    // -- /FEATURE: Scene --
    
    // -- CORE: render --
    // --- Main Render Loop (Desktop) ---

    function loop(t) {
        // Calculate delta time
        const dt = ((t - last) / 1000) || 0;
        last = t;

        // Update user position
        const mv = getMove();
        step(dt, mv);

        // Update camera matrices
        buildViewProj();

        // --- Rendering ---
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Render Sky
        
        // Noise texture for clouds

        // Render Grid
        gl.useProgram(PG);
        gl.bindVertexArray(vao);
        gl.uniformMatrix4fv(uM, false, M);
        gl.uniformMatrix4fv(uV, false, V);
        gl.uniformMatrix4fv(uP, false, P);
        if (beastMode===true){
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.FRONT)}
        else {gl.disable(gl.CULL_FACE);};
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Render Grass in multiple passes for density and LOD
        
        // Render L-System Plants
        {
            gl.useProgram(PPLANTS);
            gl.bindVertexArray(vaoPlants);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(false); // Render transparent objects without writing to depth buffer

            const camX = user.x;
            const camZ = user.z;
            const plants = genPlants(camX, camZ);

            for(const p of plants){
                const px = p.px, pz = p.pz, scale = p.scale;

                // Distance & LOD
                const dx = camX - px, dz = camZ - pz;
                const dist = Math.hypot(dx, dz);

                const NEAR_HIDE = 4.0;
                const NEAR_FULL = 6.0;
                const FAR_START = 18.0;
                const FAR_HIDE  = 50.0;
                if(dist < NEAR_HIDE || dist > FAR_HIDE) continue;

                const MIN_ITER = 2, MAX_ITER = 14;
                const sstep = x => x*x*(3-2*x);
                let a = (dist - NEAR_HIDE)/(NEAR_FULL-NEAR_HIDE); a = sstep(Math.min(1, Math.max(0,a)));
                let b = (FAR_HIDE - dist)/(FAR_HIDE - FAR_START); b = sstep(Math.min(1, Math.max(0,b)));
                let q = a * b;
                if(q < 0.05) continue;

                const key = p.gx + ',' + p.gz;
                const target = MIN_ITER + q*(MAX_ITER - MIN_ITER);
                const iterations = Math.max(MIN_ITER, Math.min(MAX_ITER, target)) | 0;
                const plantSeed = plantHash(p.gx, p.gz, 4.0);

                const angle = ATAN2(camX - px, camZ - pz);
                const MPlants = new DOMMatrix()
                    .translate(px, 0, pz)
                    .rotate(0, angle * 57.295775 /*180 / PI*/, 0) // DOMMatrix uses degrees
                    .scale(scale, scale, scale)
                    .toFloat32Array();

                gl.uniformMatrix4fv(uMPla, false, MPlants);
                gl.uniformMatrix4fv(uVPla, false, V);
                gl.uniformMatrix4fv(uPPla, false, P);
                gl.uniform1f(uTimePla, t * 0.001);
                gl.uniform1i(uMaxIterationsPla, iterations);
                gl.uniform3f(uPlantPosPla, px, 0, pz);
                gl.uniform1f(uPlantSeedPla, plantSeed);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }

        // Render Reticle if there's a ground hit
        
        // Render HUD
        
        requestAnimationFrame(loop);
    }

    // Helper to update the HUD canvas content
    
    // Helper to submit a grass draw call

    // Computes the view and projection matrices for desktop mode
    function buildViewProj() {
        const cy = COS(user.yaw),
              sy = SIN(user.yaw);
        const cp = COS(user.pitch),
              sp = SIN(user.pitch);
        const eye = [user.x, user.y, user.z];
        const center = [user.x - sy * cp, user.y - sp, user.z - cy * cp];
        LOOKAT(V, eye, center, [0, 1, 0]);
        PERSP(P, 60, canvas.width / canvas.height, 0.01, 1e3);
        PV = MULTMAT4(M4(), P, V);
        invPV = INV(PV);
    }
    // -- /CORE: Render --

    // -- FEATURE: VR --
    // -- /FEATURE: VR --
    
    // -- FEATURE: CORE --
    // --- Application Entry Point ---
    (function main() {
        requestAnimationFrame(loop);
    })();
    
    // -- /FEATURE: CORE --
    </script>
</body>
</html>
