<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>'Wild Catch' 13K Game 2025</title>
    <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="55%" x="50%" dominant-baseline="middle" text-anchor="middle" font-size="80">üêà‚Äç‚¨õ</text></svg>'>
    <style>
        /* Basic styles to make the canvas and joysticks fill the screen */
        html, body {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }

        /* Styling for the virtual joysticks */
        .joystick {
            position: fixed;
            width: 112px;
            height: 112px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.25);
            z-index: 10;
            display: none; /* Hidden by default, shown for touch devices */
        }

        /* The movable part of the joystick */
        .joystick-handle {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* The handle itself doesn't capture clicks */
        }

        /* Positioning for left and right joysticks */
        #leftJoy { bottom: 36px; left: 36px; }
        #rightJoy { bottom: 36px; right: 36px; }

        /* Media query to show joysticks only on touch-capable (coarse pointer) devices */
        @media (pointer:coarse) {
            .joystick { display: block; }
        }
    </style>
</head>
<body>
    <!-- The main canvas for WebGL rendering -->
    <!-- <canvas id="C"></canvas> -->
    <canvas id="canvas"></canvas>

    <!-- HTML elements for the virtual joysticks -->
    <div id="leftJoy" class="joystick"><div class="joystick-handle"></div></div>
    <div id="rightJoy" class="joystick"><div class="joystick-handle"></div></div>

    <script>
    // -- FEATURE: Core --
    // Expose Math functions to global scope
    Object.getOwnPropertyNames(Math).forEach(n => window[n.toUpperCase()] = Math[n]);
    // --- Math Library ---
    const D2R = 0.0174532925 // or PI / 180;
    const F32 = Float32Array;
    const M4 = (v) => new F32(v || [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
    const V3 = (v) => new F32(v || 3);
    const T_V3_A = V3(), T_V3_B = V3(), T_V3_C = V3(); // Reusable temporary V3s
    const T_V4_A = V3(4), T_V4_B = V3(4); // Reusable temporary V4s
    const T_V3_RAY_O = V3(), T_V3_RAY_D = V3(); // For raycasting results (Origin, Direction)
    const SUB=(t,n,r)=>(t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t);
    const DOT=(t,n)=>t[0]*n[0]+t[1]*n[1]+t[2]*n[2];
    const CROSS=(t,n,r)=>(t[0]=n[1]*r[2]-n[2]*r[1],t[1]=n[2]*r[0]-n[0]*r[2],t[2]=n[0]*r[1]-n[1]*r[0],t);
    const LEN=(t)=>HYPOT(t[0],t[1],t[2]);
    const NORM=(t,n)=>{var r=LEN(n);return r>0&&(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r),t};
    const MULTMAT4 = (o, a, b) => (o.set((new DOMMatrix(a)).multiply(new DOMMatrix(b)).toFloat32Array()), o);
    const INV = (m) => (new DOMMatrix(m)).inverse().toFloat32Array();
    const PERSP = (o, f, a, n, fa) => { const t = 1 / TAN(f * D2R / 2); o.set([t/a,0,0,0, 0,t,0,0, 0,0,(fa+n)/(n-fa),-1, 0,0,(2*fa*n)/(n-fa),0]); return o; };
    const LOOKAT = (o, e, c, u) => { SUB(T_V3_A,e,c); NORM(T_V3_A,T_V3_A); CROSS(T_V3_B,u,T_V3_A); NORM(T_V3_B,T_V3_B); CROSS(T_V3_C,T_V3_A,T_V3_B); o.set([T_V3_B[0],T_V3_C[0],T_V3_A[0],0, T_V3_B[1],T_V3_C[1],T_V3_A[1],0, T_V3_B[2],T_V3_C[2],T_V3_A[2],0, -DOT(T_V3_B,e),-DOT(T_V3_C,e),-DOT(T_V3_A,e),1]); return o; };
    // --- World Matrices ---
    const M = M4(), V = M4(), P = M4(); // Model, View, Projection
    let PV = M4(), invPV = M4(); // Combined and inverse matrices for picking

    // Multiplies a 3D point (w=1) by a 4x4 matrix
    function mulPoint(m, p) { const x=p[0],y=p[1],z=p[2],w=1; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    // Multiplies a 3D direction (w=0) by a 4x4 matrix
    function mulDir(m, d) { const x=d[0],y=d[1],z=d[2],w=0; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    //function mul4(m, v) { return [m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3], m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3], m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3], m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3]]; }
    const mul4 = (out, m, v) => {
        const v0=v[0], v1=v[1], v2=v[2], v3=v[3];
        out[0] = m[0]*v0 + m[4]*v1 + m[8]*v2 + m[12]*v3;
        out[1] = m[1]*v0 + m[5]*v1 + m[9]*v2 + m[13]*v3;
        out[2] = m[2]*v0 + m[6]*v1 + m[10]*v2 + m[14]*v3;
        out[3] = m[3]*v0 + m[7]*v1 + m[11]*v2 + m[15]*v3;
        return out;
    };
    


    // Creates a translation and scale matrix
    function translateScale(x,y,z,sx,sy,sz) { return new F32([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, x,y,z,1]); }

    // const D = document
    // const C = D.getElementById('canvas');
    const canvas = document.getElementById('canvas');
    
   // State variables for the user/camera, rendering loop, and WebGL/WebXR contexts
    let user = { x: 0, y: 1.6, z: 2, yaw: 0, pitch: 0 }; // User position and orientation
    let last = 0; // Timestamp of the last frame for calculating delta time
    let gl, xr = null, ref = null, off = null; // WebGL and WebXR objects

    gl = canvas.getContext('webgl2', { antialias: true, xrCompatible: true });
    if (!gl) { alert('WebGL2 is required for this application.'); }

    // Resize the canvas to fill the window, accounting for device pixel ratio
    function resize() {
        const w = innerWidth, h = innerHeight, dpr = devicePixelRatio || 1;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
    }
    addEventListener('resize', resize);
    resize(); // Initial resize

    // Helper function to compile and link a shader program
    function prog(vs, fs) {
        const p = gl.createProgram();
        const v = gl.createShader(gl.VERTEX_SHADER);
        const f = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(v, vs); gl.compileShader(v);
        if (!gl.getShaderParameter(v, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(v);
        gl.shaderSource(f, fs); gl.compileShader(f);
        if (!gl.getShaderParameter(f, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(f);
        gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
        return p;
    }
    // -- /FEATURE: Core --

    // -- FEATURE: Input --
    // -- MODULE: Input-Core --
    // --- Unified Input Handling ---
    // Check if the primary input is a coarse pointer (like a finger), indicating a mobile/touch device
    const isMobile = matchMedia('(pointer:coarse)').matches;
    // Unified input state object for keyboard, joysticks, pointer-look, and pointer coordinates
    const input = {
        keys: {},
        joy: { left: { x: 0, y: 0, id: null }, right: { x: 0, y: 0, id: null } }, // 
        look: { id: null, x: 0, y: 0 },
        pointer: { x: 0, y: 0 }
    };
    const DZ = 0.1;    // Deadzone for joystick/gamepad axes to prevent drift
    // A map to track the previous pressed state of VR controller buttons for edge detection (press/release)
    const pressedMap = new Map();

    // State for the raycast
    let lastHit = null;
    // -- /MODULE: Input-Core --
    
    // -- MODULE: Input-KeyPoint --
    // Keyboard event listeners for movement and HUD toggle
    document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        input.keys[k] = true;
        if (k === 'h' || k === 'escape') {playClickSound(); hudVisible = !hudVisible;} // 'H' and escape key toggles HUD visibility
        if (k === 'f') {playClickSound(); beastMode = !beastMode;} // 'F' key toggles beastMode
    });
    document.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
    
    // Pointer event listeners on the canvas for mouse-look and interaction
    canvas.addEventListener('pointerdown', e => {
        initAudio(); // NEW: Initialize audio on first user interaction
        // Start mouse-look on left-click
        if (e.button === 0 && input.look.id === null) {
            input.look.id = e.pointerId;
            input.look.x = e.clientX;
            input.look.y = e.clientY;
            canvas.setPointerCapture(e.pointerId); // Lock the pointer to the canvas
        }
        // Always update pointer position for picking
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
    });
    
    canvas.addEventListener('pointermove', e => {
        // Update pointer position for hover effects
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
        
        // If we are in mouse-look mode, update camera orientation
        if (e.pointerId === input.look.id) {
            const dx = e.clientX - input.look.x;
            const dy = e.clientY - input.look.y;
            input.look.x = e.clientX;
            input.look.y = e.clientY;
            user.yaw += dx * 0.002;
            user.pitch = MAX(-PI / 2+0.001, MIN(PI / 2-0.001, user.pitch - dy * 0.002));
        }
    });
    
    canvas.addEventListener('pointerup', e => {
        // Stop mouse-look mode.
        if (e.pointerId === input.look.id) {
            input.look.id = null;
        }
        // Update pointer position and trigger an interaction check
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
    });
    
    canvas.addEventListener('pointercancel', e => {
        if (e.pointerId === input.look.id) {
            input.look.id = null;
        }
    });
    // -- /MODULE: Input-KeyPoint --
    
    // -- MODULE: Input-Joystick --

    // -- /MODULE:Input-Joystick --

    // -- MODULE: Input-Ray --
   
    // -- /MODULE: Input-Ray --

    // -- /FEATURE: Input --

    // -- FEATURE: Gameplay --
    let beastMode = false; // toggle beast mode
    // -- MODULE: Gameplay-Item --
    const BOOST_DURATION = 15;          // seconds per pickup
    const BOOST_AMOUNT  = 0.5;        // +50% per stack
    const MAX_BOOSTS    = 100;           // safety cap
    const speedBoosts = [];            // {timeLeft, amount}
    const items = [];                  // pickup spheres {x,y,z,r,active:true}
    const obstacles = [];              // solid spheres for collision {x,y,z,r}
    const playerCapsule = { radius: 0.5, height: 1.6, eyeOffset: 1.6 };

    function spawnTestContent(){
        // Pickup items
        for (let i=0;i<26;i++){
            items.push({ x: i*2 - 5, y: 0.5, z: -4 - i*2, r:0.4, active:true });
        }
        // One obstacle sphere to demonstrate collision
        obstacles.push({ x: 0, y: 0.8, z: -2, r: 0.8 });
    }
    spawnTestContent();

    function currentSpeedMult(){
        let m = 1;
        for (const b of speedBoosts) m += b.amount;
        return m;
    }

    function updateBoosts(dt){
        for (let i=speedBoosts.length-1;i>=0;i--){
            speedBoosts[i].timeLeft -= dt;
            if (speedBoosts[i].timeLeft<=0) speedBoosts.splice(i,1);
        }
    }

    function tryPickupItems(){
        // Closest point on capsule (horizontal only since player moves on XZ)
        const baseY = user.y - playerCapsule.eyeOffset;
        const topY  = baseY + playerCapsule.height;
        for (const itm of items){
            if (!itm.active) continue;
            // Nearest Y on capsule segment
            const ny = MAX(baseY, MIN(topY, itm.y));
            const dx = itm.x - user.x;
            const dy = itm.y - ny;
            const dz = itm.z - user.z;
            const dist = HYPOT(dx,dy,dz);
            if (dist < itm.r + playerCapsule.radius){
                itm.active = false;
                if (speedBoosts.length < MAX_BOOSTS){
                    speedBoosts.push({ timeLeft: BOOST_DURATION, amount: BOOST_AMOUNT });
                }
                playClickSound && playClickSound();
            }
        }
    }

    function resolveCollisions(prevX, prevZ){
        // Capsule vs sphere obstacles
        const baseY = user.y - playerCapsule.eyeOffset;
        const topY  = baseY + playerCapsule.height;
        for (const o of obstacles){
            const ny = MAX(baseY, MIN(topY, o.y));
            let dx = user.x - o.x;
            let dy = ny - o.y;
            let dz = user.z - o.z;
            const dist = HYPOT(dx,dy,dz);
            const minDist = playerCapsule.radius + o.r;
            if (dist < minDist){
                if (dist < 1e-4){ // avoid division by zero
                    user.x = prevX; user.z = prevZ;
                } else {
                    const push = (minDist - dist);
                    dx /= dist; dz /= dist; // horizontal push preferred
                    user.x += dx * push;
                    user.z += dz * push;
                }
            }
        }
        // Ground collision (keep eye at least capsule height above 0)
        if (user.y - playerCapsule.eyeOffset < 0) user.y = playerCapsule.eyeOffset;
    }
    // -- /MODULE: Gameplay-Items --

    // -- MODULE: Gameplay-Movement --
    // --- Movement Logic ---
    // Movement and input constants
    const MOVES = 3;    // Movement speed in meters per second
    const TURNS = 2;    // Turning speed in radians per second

    // Consolidates input from keyboard, joysticks, and VR controllers into a single movement vector
    function getMove(session) {
        let vx = 0, vy = 0, vt = 0;
        // -- SOLUTION: Gameplay-Movement-Keyboard --
        // Keyboard input (WASD for move, QE for turn)
        const kx = (+!!input.keys.d) - (+!!input.keys.a);
        const ky = (+!!input.keys.w) - (+!!input.keys.s);
        const kt = (+!!input.keys.q) - (+!!input.keys.e);
        // -- /SOLUTION: Gameplay-Movement-Keyboard --
    
        // -- SOLUTION: Gameplay-Movement-Joystick --
        // Virtual joystick input
        const jx = input.joy.left.x;
        const jy = -input.joy.left.y;
        const jt = -input.joy.right.x;
        // -- /SOLUTION: Gameplay-Movement-Joystick --

        // -- SOLUTION: Gameplay-Movement-VR --
        
        // -- /SOLUTION: Gameplay-Movement-VR --

        // Return combined movement, prioritizing VR, then keyboard, then joystick
        return { x: vx || kx || jx, y: vy || ky || jy, t: vt || kt || jt };
    }

    // -- SOLUTION: Gameplay-Movement-Step --
    // Updates the user's position and orientation based on movement input and delta time
    function step(dt, mv) {
        // New movement logic
        updateBoosts(dt);
        const speed = MOVES * (currentSpeedMult());
        // Apply movement
        const now = performance.now();
        const moveMagnitude = HYPOT(mv.x, mv.y);
        if(moveMagnitude > 0.1 && now - lastStepTime > stepInterval){
            playStepSound();
            lastStepTime = now;
        }
        user.yaw += mv.t * TURNS * dt; // Apply turning
        
        // Calculate forward and right vectors based on current yaw
        const cy = COS(user.yaw);
        const sy = SIN(user.yaw);
        T_V3_A[0] = -sy; T_V3_A[1] = 0; T_V3_A[2] = -cy; // 'f' vector
        T_V3_B[0] = cy;  T_V3_B[1] = 0; T_V3_B[2] = -sy;  // 'r' vector
        //const sp = MOVES * dt;
        const sp = speed * dt;
        // collision resolution
        const prevX = user.x, prevZ = user.z;

        // Apply movement along forward and right vectors
        user.x += (T_V3_B[0] * mv.x + T_V3_A[0] * mv.y) * sp;
        user.z += (T_V3_B[2] * mv.x + T_V3_A[2] * mv.y) * sp;
        // Resolve collisions with obstacles
        resolveCollisions(prevX, prevZ);
        tryPickupItems();

    }
    // -- /SOLUTION: Gameplay-Movement-Step --
    // -- /MODULE: Gameplay-Movement --
    // -- /FEATURE: Gameplay --
    
    // -- FEATURE: Scene --
    // -- MODULE: Scene-Audio --
    // todo: implement stereo sources to get spatial audio (directional wind sound)
    let audioCtx = null;
    let lastStepTime = 0;
    const stepInterval = 500; // ms between walking sounds
    
    function initAudio(){
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (!window.windPlaying) { window.windPlaying = true; playWindSound(); }

    }
    // -- SOLUTION: Scene-Audio-Wind --
    function playWindSound(){
    }
    // -- /SOLUTION: Scene-Audio-Wind --
    // -- SOLUTION: Scene-Audio-Click --
    function playClickSound(){  
    }
    // -- /SOLUTION: Scene-Audio-Click --
    // -- SOLUTION: Scene-Audio-Step --
    function playStepSound(){
    }
    // -- /SOLUTION: Scene-Audio-Step --
    // -- /MODULE: Scene-Audio --

    // -- MODULE: Scene-HUD --
    // -- /MODULE: Scene-HUD --
    // -- MODULE: Scene-Sky --
    // --- Sky Shader ---
    let noiseTex = gl.createTexture();
    
    // -- /MODULE: Scene-Sky --
    // -- MODULE: Scene-Ground --
    // --- Grid Shader ---
    // A simple shader to draw a grid on the ground plane
    const vsG = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 p;
    uniform mat4 M, V, P;
    out vec3 w;
    void main(){
        w = (M * vec4(p,1.)).xyz;
        gl_Position = P * V * vec4(w,1.);
    }`;
    const fsG = `#version 300 es
    precision highp float;
    in vec3 w;
    out vec4 o;
    float h(vec2 v){return fract(sin(dot(v,vec2(41.,289.)))*9000.);}
    void main(){
        vec2 q = floor(w.xz / .6);
        float r = h(q), r2 = h(q + 13.);
        // Base tile color with occasional lighter specks
        vec3 c = mix(vec3(.08,.05,.02), vec3(.3,.2,.1), r) + step(.97, r2) * vec3(.1,.08,.04);
        // Removed distance-based darkening to keep texture infinite
        o = vec4(c, 1.);
    }`;

    const PG = prog(vsG, fsG);
    const uM = gl.getUniformLocation(PG, 'M');
    const uV = gl.getUniformLocation(PG, 'V');
    const uP = gl.getUniformLocation(PG, 'P');
    const vbo = gl.createBuffer();
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    // A large quad to serve as the ground plane.
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1e3,0,-1e3, 1e3,0,-1e3, 1e3,0,1e3, -1e3,0,-1e3, 1e3,0,1e3, -1e3,0,1e3]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    // -- /MODULE: Scene-Ground --
    
    // -- MODULE: Gameplay-item --
    // NEW: Sphere (items/obstacles) minimal shader + geometry
    const vsSphere = `#version 300 es
    layout(location=0) in vec3 p;
    uniform mat4 V,P;
    uniform vec3 uPos;
    uniform float uS;
    void main(){
        vec3 wp = p * uS + uPos;
        gl_Position = P * V * vec4(wp,1.0);
    }`;
    const fsSphere = `#version 300 es
    precision highp float;
    uniform vec3 uColor;
    out vec4 o;
    void main(){ o = vec4(uColor,1.0); }`;

    function buildSphere(lat=10, lon=12){
        const v=[];
        for(let i=0;i<lat;i++){
            const t1=PI*i/lat, t2=PI*(i+1)/lat;
            for(let j=0;j<lon;j++){
                const p1=2*PI*j/lon, p2=2*PI*(j+1)/lon;
                const quad=[
                    sph(t1,p1),sph(t2,p1),sph(t2,p2),
                    sph(t1,p1),sph(t2,p2),sph(t1,p2)
                ];
                for(const q of quad) v.push(q[0],q[1],q[2]);
            }
        }
        return new Float32Array(v);
    }
    function sph(t,p){ return [SIN(t)*COS(p), COS(t), SIN(t)*SIN(p)]; }

    const PS = prog(vsSphere, fsSphere);
    const sphereVao = gl.createVertexArray();
    const sphereBuf = gl.createBuffer();
    gl.bindVertexArray(sphereVao);
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuf);
    const sphereVerts = buildSphere();
    gl.bufferData(gl.ARRAY_BUFFER, sphereVerts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
    const uS_V = gl.getUniformLocation(PS,'V');
    const uS_P = gl.getUniformLocation(PS,'P');
    const uS_Pos = gl.getUniformLocation(PS,'uPos');
    const uS_S = gl.getUniformLocation(PS,'uS');
    const uS_Color = gl.getUniformLocation(PS,'uColor');

    // -- /MODULE: Gameplay-item --

    // -- MODULE: Scene-Rocks --
    // Stylized low-poly rocks: deterministic placement, flat-ish shading, and collision integration
    const rocks = []; // currently active rock descriptors {x,y,z,r,seed}

    // Simple deterministic hash for rock placement
    function rockHash(ix, iz, salt){
        const s = SIN(ix*127.1 + iz*311.7 + salt*13.13) * 43758.5453;
        return s - FLOOR(s);
    }

    // Build a low-res sphere for rock base (coarse facets)
    const rockVerts = buildSphere(6, 8); // fewer subdivisions -> larger facets
    const PRock_vs = `#version 300 es
    layout(location=0) in vec3 p;
    uniform mat4 V, P;
    uniform vec3 uPos;
    uniform float uS;
    uniform float uSeed;
    out vec3 vLocal;
    // cheap hash noise
    float h(float x){ return fract(sin(x)*43758.5453); }
    void main(){
        // Displace vertex along its normal-ish direction using a cheap noise based on seed and vertex
        vec3 local = p * uS;
        float n = h((local.x + local.y*1.7 + local.z*2.3) * (uSeed + 1.0));
        float off = (n - 0.5) * (0.5 * uS); // displacement magnitude
        // push outward roughly by position vector (acts like normal)
        vec3 wp = (local + normalize(local) * off) + uPos;
        vLocal = local;
        gl_Position = P * V * vec4(wp, 1.0);
    }`;

    const PRock_fs = `#version 300 es
    precision highp float;
    in vec3 vLocal;
    out vec4 o;
    uniform float uSeed;
    // quantize shading to get flat bands
    void main(){
        vec3 baseA = vec3(0.35, 0.3, 0.2);
        vec3 baseB = vec3(0.15, 0.1, 0.1);
        // fake normal from position
        vec3 n = normalize(vLocal + vec3(0.0,0.0,-2.5));
        float shade = dot(n, normalize(vec3(0.0,0.1,-0.5)));
        shade = clamp(shade, 0.0, 1.0);
        // quantize into 4 levels
        float q = floor(shade * 4.0) / 4.0;
        // subtle pattern variation
        //float grain = fract(sin((vLocal.x+vLocal.y*7.7+vLocal.z*13.3) * (uSeed+1.0)) * 43758.5453) * 0.06;
        vec3 col = mix(baseB, baseA, q);// + grain;
        o = vec4(col, 1.0);
    }`;

    const PROCK = prog(PRock_vs, PRock_fs);
    const rockVao = gl.createVertexArray();
    const rockBuf = gl.createBuffer();
    gl.bindVertexArray(rockVao);
    gl.bindBuffer(gl.ARRAY_BUFFER, rockBuf);
    gl.bufferData(gl.ARRAY_BUFFER, rockVerts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    const uR_V = gl.getUniformLocation(PROCK, 'V');
    const uR_P = gl.getUniformLocation(PROCK, 'P');
    const uR_Pos = gl.getUniformLocation(PROCK, 'uPos');
    const uR_S = gl.getUniformLocation(PROCK, 'uS');
    const uR_Seed = gl.getUniformLocation(PROCK, 'uSeed');

    // Parameters for rock field
    const ROCK_CELL = 5;
    const ROCK_RADIUS = 200.0; // generation radius
    const ROCK_PROB = 0.01;   // spawn probability per cell

    // Update rocks around camera and sync to obstacles array (mark obstacles with _isRock)
    function updateRocks(camX, camZ){
        // remove previous rock-marked obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            if (obstacles[i]._isRock) obstacles.splice(i, 1);
        }
        rocks.length = 0;
        const c = ROCK_CELL; const r = ROCK_RADIUS;
        const minX = FLOOR((camX - r)/c);
        const maxX = FLOOR((camX + r)/c);
        const minZ = FLOOR((camZ - r)/c);
        const maxZ = FLOOR((camZ + r)/c);
        for(let gz=minZ; gz<=maxZ; gz++){
            for(let gx=minX; gx<=maxX; gx++){
                const h = rockHash(gx, gz, 0.0);
                if (h < ROCK_PROB){
                    const jx = rockHash(gx, gz, 1.0) - 0.5;
                    const jz = rockHash(gx, gz, 2.0) - 0.5;
                    const px = gx*c + (jx * c * 0.6) + c*0.5;
                    const pz = gz*c + (jz * c * 0.6) + c*0.5;
                    const dx = px - camX, dz = pz - camZ;
                    if (dx*dx + dz*dz <= r*r){
                        const seed = rockHash(gx, gz, -7.0) * 1000.0;
                        const scale = 4.0 + rockHash(gx, gz, 5.0) * 2.; // 1.0 .. 6.0 meters
                        const rx = px, rz = pz, ry = scale * 0.45; // small y offset
                        const radius = scale * 1.2; // collision radius
                        const rock = { x: rx, y: ry, z: rz, r: radius, seed, scale };
                        rocks.push(rock);
                        // also add to obstacles so collision code picks it up
                        obstacles.push({ x: rx, y: ry, z: rz, r: radius, _isRock: true });
                    }
                }
            }
        }
    }

    // -- /MODULE: Scene-Rocks --

    // -- MODULE: Scene-Grass --
    
    // -- /MODULE: Scene-Grass --
    // -- MODULE: Scene-Plant --
    
    // -- /MODULE: Scene-Plant --
    
    // -- MODULE: Scene-Reticle --
    // -- /MODULE: Scene-Reticle --

    // -- MODULE: Scene-VR --
    // -- /MODULE: Scene-VR --

    // -- /FEATURE: Scene --
    
    // -- CORE: render --
    // --- Main Render Loop (Desktop) ---

    function loop(t) {
        // If an immersive XR session is active, stop the desktop loop chain.
        if (xr) return;  // prevents scheduling the next frame; XR loop takes over

        // Calculate delta time
        const dt = ((t - last) / 1000) || 0;
        last = t;
        // Ensure rocks near the player are generated and present in obstacles for collision resolution
        updateRocks && updateRocks(user.x, user.z);

        // Update user position
        const mv = getMove();
        step(dt, mv);

        // Update camera matrices
        buildViewProj();
        // NEW: update wind stereo each frame (after camera matrix updated)
        // --- Rendering ---
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Render Sky
        
        // Noise texture for clouds

        // Render Grid
        gl.useProgram(PG);
        gl.bindVertexArray(vao);
        gl.uniformMatrix4fv(uM, false, M);
        gl.uniformMatrix4fv(uV, false, V);
        gl.uniformMatrix4fv(uP, false, P);
        if (beastMode===true){
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.FRONT)}
        else {gl.disable(gl.CULL_FACE);};
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // --- NEW: Render Items & Obstacles (now works because drawSphere exists) ---
        for(const itm of items) if (itm.active) drawSphere(itm.x,itm.y,itm.z,itm.r,[0.2,1.0,0.3]);
        for(const o of obstacles) if(!o._isRock) drawSphere(o.x,o.y,o.z,o.r,[0.9,0.2,0.2]);

        // Draw procedural rocks (flat-shaded, stylized)
        gl.useProgram(PROCK);
        gl.bindVertexArray(rockVao);
        gl.uniformMatrix4fv(uR_V, false, V);
        gl.uniformMatrix4fv(uR_P, false, P);
        for(const rk of rocks){
            gl.uniform3f(uR_Pos, rk.x, rk.y, rk.z);
            gl.uniform1f(uR_S, rk.scale);
            gl.uniform1f(uR_Seed, rk.seed);
            gl.drawArrays(gl.TRIANGLES, 0, rockVerts.length / 3);
            gl.enable(gl.DEPTH_TEST);
        }

        // Render Grass in multiple passes for density and LOD
        
        // Render L-System Plants
        
        // Render HUD
        
        requestAnimationFrame(loop);
    }

    // Helper to update the HUD canvas content
    function updHUD(mode, hit, uiSet, dt) {
        drawHUDCanvas(mode, hit, uiSet, dt);
    }

    // Helper to submit a sphere draw call
    function drawSphere(x,y,z,r,col){
        gl.useProgram(PS);
        gl.bindVertexArray(sphereVao);
        gl.uniformMatrix4fv(uS_V,false,V);
        gl.uniformMatrix4fv(uS_P,false,P);
        gl.uniform3f(uS_Pos,x,y,z);
        gl.uniform1f(uS_S,r);
        gl.uniform3f(uS_Color,col[0],col[1],col[2]);
        gl.drawArrays(gl.TRIANGLES,0,sphereVerts.length/3);
    }

    // Helper to submit a grass draw call

    // Computes the view and projection matrices for desktop mode
    function buildViewProj() {
        const cy = COS(user.yaw),
              sy = SIN(user.yaw);
        const cp = COS(user.pitch),
              sp = SIN(user.pitch);
        const eye = [user.x, user.y, user.z];
        const center = [user.x - sy * cp, user.y - sp, user.z - cy * cp];
        LOOKAT(V, eye, center, [0, 1, 0]);
        PERSP(P, 60, canvas.width / canvas.height, 0.01, 1e3);
        PV = MULTMAT4(M4(), P, V);
        invPV = INV(PV);
    }
    // -- /CORE: Render --

    // -- FEATURE: VR --
    
    // -- /FEATURE: VR --
    
    // -- FEATURE: CORE --
    // --- Application Entry Point ---
    (function main() {
        requestAnimationFrame(loop);
    })();
    
    // -- /FEATURE: CORE --
    </script>
</body>
</html>
