<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wild Catch</title>
    <!--meta name="author" content="Justinas Gibas" /-->
    <!--<link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="55%" x="50%" dominant-baseline="middle" text-anchor="middle" font-size="80">üêà‚Äç‚¨õ</text></svg>'>-->
    <style>
        /* Basic styles to make the canvas and joysticks fill the screen */
        html, body {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }

        /* Styling for the virtual joysticks */
        .j {
            position: fixed;
            width: 112px;
            height: 112px;
            border-radius: 50%;
            background: rgba(255, 255, 200, .08);
            border: 2px solid rgba(255, 255, 200, .3);
            z-index: 10;
            display: none; /* Hidden by default, shown for touch devices */
        }
 
        /* The movable part of the joystick */
        .jh {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 150, .6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* The handle itself doesn't capture clicks */
        }

    /* Positioning for left and right joysticks */
    #L { bottom: 36px; left: 36px; }
    #R { bottom: 36px; right: 36px; }

        /* Media query to show joysticks only on touch-capable (coarse pointer) devices */
        @media (pointer:coarse) {
            .j { display: block; }
        }
    </style>
</head>
<body>
    <!-- The main canvas for WebGL rendering -->
    <!-- <canvas id="C"></canvas> -->
    <canvas id="C"></canvas>

    <!-- HTML elements for the virtual joysticks -->
    <div id="L" class="j"><div class="jh"></div></div>
    <div id="R" class="j"><div class="jh"></div></div>

    <script>
    // -- FEATURE: Core --
    // Expose Math functions to global scope
    Object.getOwnPropertyNames(Math).forEach(n => window[n.toUpperCase()] = Math[n]);
    // --- Math Library ---
    //const D2R = 0.0174532925 // or PI / 180;
    const D2R = PI / 180;
    const F32 = Float32Array;
    const M4 = (v) => new F32(v || [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
    const V3 = (v) => new F32(v || 3);
    const T_V3_A = V3(), T_V3_B = V3(), T_V3_C = V3(); // Reusable temporary V3s
    const T_V4_A = V3(4), T_V4_B = V3(4); // Reusable temporary V4s
    const T_V3_RAY_O = V3(), T_V3_RAY_D = V3(); // For raycasting results (Origin, Direction)
    const SUB=(t,n,r)=>(t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t);
    const DOT=(t,n)=>t[0]*n[0]+t[1]*n[1]+t[2]*n[2];
    const CROSS=(t,n,r)=>(t[0]=n[1]*r[2]-n[2]*r[1],t[1]=n[2]*r[0]-n[0]*r[2],t[2]=n[0]*r[1]-n[1]*r[0],t);
    const LEN=(t)=>HYPOT(t[0],t[1],t[2]);
    const NORM=(t,n)=>{var r=LEN(n);return r>0&&(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r),t};
    const MULTMAT4 = (o, a, b) => (o.set((new DOMMatrix(a)).multiply(new DOMMatrix(b)).toFloat32Array()), o);
    const INV = (m) => (new DOMMatrix(m)).inverse().toFloat32Array();
    const PERSP = (o, f, a, n, fa) => { const t = 1 / TAN(f * D2R / 2); o.set([t/a,0,0,0, 0,t,0,0, 0,0,(fa+n)/(n-fa),-1, 0,0,(2*fa*n)/(n-fa),0]); return o; };
    const LOOKAT = (o, e, c, u) => { SUB(T_V3_A,e,c); NORM(T_V3_A,T_V3_A); CROSS(T_V3_B,u,T_V3_A); NORM(T_V3_B,T_V3_B); CROSS(T_V3_C,T_V3_A,T_V3_B); o.set([T_V3_B[0],T_V3_C[0],T_V3_A[0],0, T_V3_B[1],T_V3_C[1],T_V3_A[1],0, T_V3_B[2],T_V3_C[2],T_V3_A[2],0, -DOT(T_V3_B,e),-DOT(T_V3_C,e),-DOT(T_V3_A,e),1]); return o; };
    // --- World Matrices ---
    const M = M4(), V = M4(), P = M4(); // Model, View, Projection
    let PV = M4(), invPV = M4(); // Combined and inverse matrices for picking

    // Multiplies a 3D point (w=1) by a 4x4 matrix
    function mulPoint(m, p) { const x=p[0],y=p[1],z=p[2],w=1; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    // Multiplies a 3D direction (w=0) by a 4x4 matrix
    function mulDir(m, d) { const x=d[0],y=d[1],z=d[2],w=0; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    //function mul4(m, v) { return [m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3], m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3], m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3], m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3]]; }
    const mul4 = (out, m, v) => {
        const v0=v[0], v1=v[1], v2=v[2], v3=v[3];
        out[0] = m[0]*v0 + m[4]*v1 + m[8]*v2 + m[12]*v3;
        out[1] = m[1]*v0 + m[5]*v1 + m[9]*v2 + m[13]*v3;
        out[2] = m[2]*v0 + m[6]*v1 + m[10]*v2 + m[14]*v3;
        out[3] = m[3]*v0 + m[7]*v1 + m[11]*v2 + m[15]*v3;
        return out;
    };
    


    // Creates a translation and scale matrix
    function translateScale(x,y,z,sx,sy,sz) { return new F32([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, x,y,z,1]); }

    // const D = document
    // const C = D.getElementById('canvas');
    const C = document.getElementById('C');
    
    // State variables for the user/camera, rendering loop, and WebGL/WebXR contexts
     let u = { x: 0, y: 1.6, z: 2, yaw: 0, pitch: .2 }; // User position and orientation
     let prevUserX = u.x, prevUserZ = u.z; // previous frame planar position
     let userVelX = 0, userVelZ = 0;             // planar velocity for cat pursuit
    let last = 0; // Timestamp of the last frame for calculating delta time
    let gl, xr = null, ref = null, off = null; // WebGL and WebXR objects

    gl = C.getContext('webgl2', { antialias: true, xrCompatible: true });
    if (!gl) { alert('Need WebGL2'); }

    // -- FEATURE: MMO --
    // Minimal MMO support using JS13k relay. Toggle via HUD. Other players are drawn as whitish cats.
    const MMO_URL = 'wss://relay.js13kgames.com/wild-catch'; // append subpaths to shard into rooms if desired
    let mmoEnabled = false;
    let ws = null;
    let myId = null;
    const peers = new Map(); // id -> {x,z,yaw,last,hist:[{t,x,z,yaw}], sx,sz,syaw}
    let mmoSendTimer = 0;

    // Peer interpolation delay (ms). Higher = smoother but more laggy. 120ms is a good balance.
    function lerp(a,b,t){ return a + (b-a)*t; }
    function lerpAngle(a,b,t){
        let d = b - a;
        if (d > PI) d -= 2*PI; else if (d < -PI) d += 2*PI;
        return a + d * t;
    }
    function pushPeerSample(p, x, z, yaw, now){
        if (!p.hist) p.hist = [];
        p.hist.push({ t: now, x, z, yaw });
        p.last = now;
        // trim old samples
        const cutoff = now - 2000;
        while (p.hist.length && p.hist[0].t < cutoff) p.hist.shift();
        // also keep a compact last-known for quick fallback
        p.x = x; p.z = z; p.yaw = yaw;
    }
    function samplePeer(p, targetT){
        const h = p.hist; if (!h || h.length === 0) return null;
        // if only one sample or target before first -> use first/last
        if (h.length === 1) return h[0];
        if (targetT <= h[0].t) return h[0];
        const n = h.length;
        if (targetT >= h[n-1].t) return h[n-1];
        // find bracketing samples (linear scan is fine for small buffers)
        for (let i=0; i<n-1; i++){
            const a = h[i], b = h[i+1];
            if (a.t <= targetT && targetT <= b.t){
                const dt = (b.t - a.t) || 1;
                const t = (targetT - a.t) / dt;
                return {
                    t: targetT,
                    x: lerp(a.x, b.x, t),
                    z: lerp(a.z, b.z, t),
                    yaw: lerpAngle(a.yaw, b.yaw, t)
                };
            }
        }
        return h[n-1];
    }

    function logMMO(s){ log('MMO: ' + s); }

    function toggleMMO(){
        mmoEnabled = !mmoEnabled;
        if (mmoEnabled) connectMMO(); else disconnectMMO();
    }

    function disconnectMMO(){
        try { if (ws) ws.close(); } catch(_){}
        ws = null; myId = null; peers.clear();
        logMMO('disabled');
    }

    function connectMMO(){
        if (ws) try { ws.close(); } catch(_){}
        logMMO('connecting‚Ä¶');
        try {
            ws = new WebSocket(MMO_URL);
        } catch (e) {
            logMMO('WebSocket error: ' + e.message);
            return;
        }
        // send a "cat!" on open to register
        // could be extended to send a name/color/etc
        ws.onopen = _ => { try { ws.send('cat!'); } catch(_){} logMMO('connected'); };
        ws.onclose = _ => { logMMO('closed'); ws = null; if (mmoEnabled) setTimeout(connectMMO, 1000); };
        ws.onerror = _ => { /* errors surface via close */ };
        ws.onmessage = ev => handleMMOMessage(ev.data);
    }

    function handleMMOMessage(msg){
        if (typeof msg !== 'string') return;
        const c = msg[0];
        switch(c){
            case '@': myId = msg.slice(1); logMMO('my id: ' + myId); return;
            case '+': { const id = msg.slice(1); if (id && !peers.has(id)) peers.set(id, {x:0,z:0,yaw:0,last:performance.now(),hist:[]}); return; }
            case '-': { const id = msg.slice(1); peers.delete(id); return; }
        }
        // Strip optional direct prefix @targetId|payload -> payload
        let payload = msg;
        if (payload[0] === '@'){
            const bar = payload.indexOf('|');
            if (bar > 0) payload = payload.slice(bar+1);
        }
        // Expected: p|id|x|z|yaw
        if (payload[0] === 'p' && payload[1] === '|'){
            const parts = payload.split('|');
            if (parts.length >= 5){
                const id = parts[1];
                if (id && id !== myId){
                    const x = parseFloat(parts[2]);
                    const z = parseFloat(parts[3]);
                    const yaw = parseFloat(parts[4]);
                    const p = peers.get(id) || {x:0,z:0,yaw:0,last:0,hist:[]};
                    const now = performance.now();
                    const nx = isFinite(x)?x:p.x;
                    const nz = isFinite(z)?z:p.z;
                    const ny = isFinite(yaw)?yaw:p.yaw;
                    pushPeerSample(p, nx, nz, ny, now);
                    peers.set(id, p);
                }
            }
        }
    }

    function mmoTick(dt){
        if (!mmoEnabled || !ws || ws.readyState !== 1 || !myId) return;
        mmoSendTimer += dt;
        if (mmoSendTimer >= .1){ // ~10 Hz
            mmoSendTimer = 0;
            // compact broadcast with our id
            const msg = 'p|' + myId + '|' + u.x.toFixed(2) + '|' + u.z.toFixed(2) + '|' + u.yaw.toFixed(3);
            try { ws.send(msg); } catch(_){}
        }
    }

    // Unified cat model renderer (used for main cat and peers)
    const PEER_COL = [.7,.7,.8];
    function drawCat(Vmat, Pmat, x, y, z, yaw, anim, amp, col){
        const cy = COS(yaw-20), sy = SIN(yaw-20);
        function place(lx, ly, lz, r){
            const wx = x + lx*cy + lz*sy;
            const wz = z + lz*cy - lx*sy;
            drawSphere(Vmat, Pmat, wx, y + ly, wz, r, col);
        }
        // Body core (chain) + head
        place(.10,0,0,.25); place(-.05,0,0,.25); place(-.20,0,0,.24);
        place(.38,.18,0,.20);
        place(.38,.33,.12,.08);place(.38,.4,.16,.04);
        place(.38,.33,-.12,.08);place(.38,.4,-.16,.04);
        // Animated legs and tail
        const CYC = v=>SIN(v)*amp, cy0 = CYC(anim), cy1 = CYC(anim+PI), baseY = -.30;
        place(.15, baseY + cy0, .14, .09);
        place(.15, baseY + cy1,-.14, .09);
        place(-.25, baseY + cy1, .15, .09);
        place(-.25, baseY + cy0,-.15, .09);
        place(-.40,.15, cy0*.5,.14);
        place(-.55,.25, 0,.12);
        place(-.70,.30, cy1*.6,.11);
    }
    // -- /FEATURE: MMO --

    // Resize the canvas to fill the window, accounting for device pixel ratio
    function resize() {
    const w = innerWidth, h = innerHeight, dpr = devicePixelRatio || 1;
    C.width = w * dpr;
    C.height = h * dpr;
    C.style.width = w + 'px';
    C.style.height = h + 'px';
    }
    addEventListener('resize', resize);
    resize(); // Initial resize

    // Helper function to compile and link a shader program
    function prog(vs, fs) {
        // Always prepend shared header (js13k-friendly, no conditional check)
        const H = '#version 300 es\nprecision highp float;';
        vs = H + /*'#define U uniform' )+*/ vs;
        fs = H + fs;
        const p = gl.createProgram();
        const v = gl.createShader(gl.VERTEX_SHADER);
        const f = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(v, vs); gl.compileShader(v);
        if (!gl.getShaderParameter(v, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(v);
        gl.shaderSource(f, fs); gl.compileShader(f);
        if (!gl.getShaderParameter(f, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(f);
        gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
        return p;
    }
    // -- /FEATURE: Core --
    
    // -- FEATURE: Input --
    // -- MODULE: Input-Core --
    // --- Unified Input Handling ---
    // Check if the primary input is a coarse pointer (like a finger), indicating a mobile/touch device
    const isMobile = matchMedia('(pointer:coarse)').matches;
    // Unified input state object for keyboard, joysticks, pointer-look, and pointer coordinates
    const I = {
        keys: {},
        joy: { L: { x: 0, y: 0, id: null }, R: { x: 0, y: 0, id: null } }, // 
        look: { id: null, x: 0, y: 0 },
        pointer: { x: 0, y: 0 }
    };
    const DZ = .1;    // Deadzone for joystick/gamepad axes to prevent drift
    // A map to track the previous pressed state of VR controller buttons for edge detection (press/release)
    const pressedMap = new Map();

    // State for the raycast
    let lastHit = null;
    // -- /MODULE: Input-Core --
    
    // -- MODULE: Input-KeyPoint --
    // Keyboard event listeners for movement and HUD toggle
    document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        I.keys[k] = true;
        if (k === 'h'||k === 'escape'||k === 'x') {playClickSound(); hudVisible = !hudVisible;} // 'H' and escape key toggles HUD visibility
        //if (k === 'f') {playClickSound(); beastMode = !beastMode;} // 'F' key toggles beastMode
    });
    document.addEventListener('keyup', e => I.keys[e.key.toLowerCase()] = false);
    
    // Pointer event listeners on the canvas for mouse-look and interaction
    C.addEventListener('pointerdown', e => {
        initAudio(); // NEW: Initialize audio on first user interaction
        // Start mouse-look on left-click
        if (e.button === 0 && I.look.id === null) {
            I.look.id = e.pointerId;
            I.look.x = e.clientX;
            I.look.y = e.clientY;
            xr ? C.requestPointerLock() : C.setPointerCapture(e.pointerId);
        }
        // Always update pointer position for picking
        I.pointer.x = e.clientX;
        I.pointer.y = e.clientY;
    });
    
    C.addEventListener('pointermove', e => {
        // Update pointer position for hover effects
        I.pointer.x = e.clientX;
        I.pointer.y = e.clientY;
        
        // If we are in mouse-look mode, update camera orientation
        if (e.pointerId === I.look.id) {
            const dx = e.clientX - I.look.x;
            const dy = e.clientY - I.look.y;
            I.look.x = e.clientX;
            I.look.y = e.clientY;
            u.yaw += dx * .002;
            u.pitch = MAX(-PI/2+.001,MIN(PI/2-.001,u.pitch-dy *.002));
        }
    });
    
    C.addEventListener('pointerup', e => {
        // Stop mouse-look mode.
        if (e.pointerId === I.look.id) {
            I.look.id = null;
        }
        // Update pointer position and trigger an interaction check
        I.pointer.x = e.clientX;
        I.pointer.y = e.clientY;
        interactDesktopAt(e.clientX, e.clientY);
    });
    
    C.addEventListener('pointercancel', e => {
        if (e.pointerId === I.look.id) {
            I.look.id = null;
        }
    });
    // -- /MODULE: Input-KeyPoint --
    
    // -- MODULE: Input-Joystick --
    // --- Virtual Joysticks for Touch Devices ---
    function initJoysticks() {
        const joys = [
            { side: 'L', el: document.getElementById('L') },
            { side: 'R', el: document.getElementById('R') }
        ];
        const handleSel = s => document.querySelector('#' + s + ' .jh');

        for (const j of joys) {
            const handle = handleSel(j.side);
            j.el.addEventListener('pointerdown', e => { initAudio(); j.id = e.pointerId; j.el.setPointerCapture(e.pointerId); updateJoy(j, e, handle); });
            j.el.addEventListener('pointermove', e => { if (e.pointerId === j.id) updateJoy(j, e, handle); });
            j.el.addEventListener('pointerup', e => { if (e.pointerId === j.id) { resetJoy(j, handle); } });
            j.el.addEventListener('pointercancel', e => { if (e.pointerId === j.id) { resetJoy(j, handle); } });
        }

    function updateJoy(j, e, handle) {
            const r = j.el.getBoundingClientRect();
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const R = r.width / 2 - 6; // Max radius for handle movement
            const dx = e.clientX - cx;
            const dy = e.clientY - cy;
            const L = MIN(HYPOT(dx, dy), R);
            const a = ATAN2(dy, dx);

            // Normalize joystick output from -1 to 1
            const x = L > DZ * 30 ? (L / R) * COS(a) : 0;
            const y = L > DZ * 30 ? (L / R) * SIN(a) : 0;

            I.joy[j.side].x = x;
            I.joy[j.side].y = y;

            // Update handle's visual position
            handle.style.transform = `translate(calc(-50% + ${x * R}px), calc(-50% + ${y * R}px))`;
        }

        function resetJoy(j, handle) {
            I.joy[j.side].x = 0;
            I.joy[j.side].y = 0;
            handle.style.transform = 'translate(-50%, -50%)';
            j.id = null;
        }
    }
    initJoysticks();
    // -- /MODULE:Input-Joystick --
    // -- MODULE: Input-Ray --
    // --- Raycasting and Picking ---
    // Checks if a world-space ray intersects with a button on the HUD
    // -- SOLUTION: Input-Ray-Screen --
    // Creates a world-space ray from screen coordinates (for desktop mouse picking)
    function rayFromScreen(px, py) {
    const r = C.getBoundingClientRect();
        const x = ((px - r.left) / r.width) * 2 - 1;
        const y = 1 - ((py - r.top) / r.height) * 2;
        //const near = [x, y, -1, 1], far = [x, y, 1, 1];
        // Use T_V4_A for the 'near' and T_V4_B for the 'far' vector4s
        T_V4_A[0] = x; T_V4_A[1] = y; T_V4_A[2] = -1; T_V4_A[3] = 1;
        T_V4_B[0] = x; T_V4_B[1] = y; T_V4_B[2] = 1;  T_V4_B[3] = 1;

        // Unproject near and far points from clip space to world space
        //const n4 = mul4(invPV, near),
        //      f4 = mul4(invPV, far);
        //const n = [n4[0] / n4[3], n4[1] / n4[3], n4[2] / n4[3]];
        //const f = [f4[0] / f4[3], f4[1] / f4[3], f4[2] / f4[3]];
        
        // Unproject, writing the results back into our temporary V4s
        mul4(T_V4_A, invPV, T_V4_A);
        mul4(T_V4_B, invPV, T_V4_B);

        // Convert to 3D points, writing to our dedicated ray vectors
        T_V3_RAY_O[0] = T_V4_A[0] / T_V4_A[3]; T_V3_RAY_O[1] = T_V4_A[1] / T_V4_A[3]; T_V3_RAY_O[2] = T_V4_A[2] / T_V4_A[3]; // This is 'n' (the origin)
        T_V3_A[0]    = T_V4_B[0] / T_V4_B[3]; T_V3_A[1]    = T_V4_B[1] / T_V4_B[3]; T_V3_A[2]    = T_V4_B[2] / T_V4_B[3]; // This is 'f' (the far point)


        // Create a normalized direction vector.
        //const d = [f[0] - n[0], f[1] - n[1], f[2] - n[2]];
        //const il = 1 / HYPOT(d[0], d[1], d[2]);
        //return { o: n, d: [d[0] * il, d[1] * il, d[2] * il] };

        
        // Calculate the direction vector into T_V3_RAY_D
        SUB(T_V3_RAY_D, T_V3_A, T_V3_RAY_O);
        NORM(T_V3_RAY_D, T_V3_RAY_D);
            
        return { o: T_V3_RAY_O, d: T_V3_RAY_D };


    }
    // Handles a click/tap interaction in desktop mode
    function interactDesktopAt(px, py) {
        const ui = currentUI();
        const r = rayFromScreen(px, py);
        if (!r) return;
        const WH = HUD_WH_world;
        const h = HUD_pick(WH, r, ui);

        if (h && h.button) {
            h.button.onClick(); // A button was clicked
            return;
        }

        // If no button was clicked, check for a hit on the ground
        //const g = rayHitGround(r);
        //if (g) {
        //    lastHit = g;
        //    log('ground ' + g.map(v => v.toFixed(2)).join(','));
        //}
    }

    // Creates a world-space ray from the camera or a VR controller
    function rayFrom(mode, frame, src) {
        if (mode === 'VR' && frame) {
            // Use the controller's target ray space if available
            if (src && src.targetRaySpace) {
                const pose = frame.getPose(src.targetRaySpace, off || ref || null);
                if (pose) {
                    const m = pose.transform.matrix;
                    const o = [m[12], m[13], m[14]];
                    const d = [-m[8], -m[9], -m[10]]; // -Z is forward in WebXR.
                    return { o, d };
                }
            }
            // Fallback to any available controller
            for (const s of xr.inputSources) {
                if (s.targetRaySpace) {
                    const pose = frame.getPose(s.targetRaySpace, off || ref || null);
                    if (pose) {
                        const m = pose.transform.matrix;
                        const o = [m[12], m[13], m[14]];
                        const d = [-m[8], -m[9], -m[10]];
                        return { o, d };
                    }
                }
            }
            // Fallback to gaze/head pose
            const pose = frame.getViewerPose(off || ref || null);
            if (pose) {
                const m = pose.views[0].transform.matrix;
                return { o: [m[12], m[13], m[14]], d: [-m[8], -m[9], -m[10]] };
            }
        } else { // Desktop mode
            const cy = COS(u.yaw), sy = SIN(u.yaw);
            const cp = COS(u.pitch), sp = SIN(u.pitch);
            T_V3_RAY_D[0] = -sy * cp; T_V3_RAY_D[1] = -sp; T_V3_RAY_D[2] = -cy * cp;
            T_V3_RAY_O[0] = u.x; T_V3_RAY_O[1] = u.y; T_V3_RAY_O[2] = u.z;
            return { o: T_V3_RAY_O, d: T_V3_RAY_D };
        }
        return null;
    }
    

    // Calculates the intersection point of a ray with the ground plane (Y=0)
    //function rayHitGround(ray) {
    //    if (!ray || ray.d[1] >= 0) return null; // Ray is parallel to or going away from the ground
    //    const t = (0 - ray.o[1]) / ray.d[1];
    //    if (t > 0) {
    //        return [ray.o[0] + ray.d[0] * t, 0.001, ray.o[2] + ray.d[2] * t];
    //    }
    //    return null;
    //}

    // Helper to get a ray from a VR controller
    function controllerRay(frame,src) {
        const pose = src.targetRaySpace ? frame.getPose(src.targetRaySpace, off || ref || null) : null;
        if (pose) {
            const m = pose.transform.matrix;
            return { o: [m[12], m[13], m[14]], d: [-m[8], -m[9], -m[10]] };
        }
        return { o: [0, 0, 0], d: [0, 0, -1] }; // Fallback, ray from Head
    }

    //const d = [-sy * cp, -sp, -cy * cp];
    //const o = [user.x, user.y, user.z];
    //return { o, d };
    //T_V3_RAY_D[0] = -sy * cp; T_V3_RAY_D[1] = -sp; T_V3_RAY_D[2] = -cy * cp;
    //T_V3_RAY_O[0] = user.x; T_V3_RAY_O[1] = user.y; T_V3_RAY_O[2] = user.z;
    //return { o: T_V3_RAY_O, d: T_V3_RAY_D };
    
    // -- /MODULE: Input-Ray --
    // -- /FEATURE: Input --

    // -- FEATURE: Gameplay --
    //let beastMode = false; // toggle beast mode
    // -- MODULE: Gameplay-Item --
    //const BOOST_DURATION = 15;          // seconds per pickup
    //const BOOST_AMOUNT  = 0.3;        // +30% per stack
    //const MAX_BOOSTS    = 100;           // safety cap
    const speedBoosts = [];            // {timeLeft, amount}
    const items = [];                  // pickup spheres {x,y,z,r>0 means alive}
    const obstacles = [];              // solid spheres for collision {x,y,z,r}
    const traps = [];                  // spheres spawnned by cat {x,y,z,r}
    // Player capsule constants (smaller than an object w/ props)
    //const CR = .5;//, CH = 1.6, CE = 1.6; // capsule radius, height, eye-offset
    let playerMoveMag = 0;             // cached player movement magnitude (for chase detection)

    // -- MODULE: Gameplay-Cat --
    // Stylized Black Cat the player must catch. Roams near center, avoids player, drops boosts & obstacles.
    const cat = { x:0, y:.6, z:0, vx:0, vz:0, caught:0, drop:1.2, baseS:2, anim:0, evade:0, yaw:0 };
    let chaseActive = false; // true when player is close and moving

    function resetCatPosition(){
        const a = RANDOM()*PI*2, r = RANDOM()*40; // within preferred radius
        cat.x = COS(a)*r; cat.z = SIN(a)*r; cat.vx = cat.vz = 0;
        // remove obstacles and traps
        traps.length = 0;
    }

    function spawnDrop(x,z){
        const boost = RANDOM()<.4;
        (boost?items:traps).push(boost?{x,y:.5,z,r:.4}:{x,y:.6,z,r:.6});
        if(audioCtx){ bell(audioCtx.currentTime, boost?870:660, window.chipMusic, boost?.1:.2); }
        if(items.length>100) items.splice(0, items.length-100);
        if(traps.length>3) traps.splice(0, traps.length-3);
    }

    function updateCat(dt){
        // Calculate the vector from the cat to the player on the XZ plane.
        const dxP = u.x - cat.x, dzP = u.z - cat.z;
        // Calculate the squared distance to the player for performance (avoids sqrt).
        const dP2 = dxP*dxP + dzP*dzP;
        // Calculate the actual distance, ensuring it's not zero to prevent division by zero.
        const dist = SQRT(dP2)||1;
        // Initialize force accumulators for this frame.
        let fx = 0, fz = 0;

        // If the player is far away (distance > 50), the cat will seek them.
        if(dist > 50){
            // Predict the player's future position for interception, limiting the look-ahead distance.
            const lead = MIN(3, dist / (cat.baseS + 5)); // look ahead time based on distance and cat speed
            // Calculate the vector to the player's predicted position.
            const tx = (u.x + userVelX*lead) - cat.x, tz = (u.z + userVelZ*lead) - cat.z;
            // Normalize the target vector to get a direction.
            const td = HYPOT(tx, tz)||1;
            // Apply a force towards the predicted position.
            fx += (tx/td)*10*(1+cat.caught*.5); fz += (tz/td)*10*(1+cat.caught*.5);
        // If the player is at a medium distance (10 to 50), the cat will orbit them.
        } else if(dist > 10){
            // Get the normalized vector towards the player.
            const nx = dxP/dist, nz = dzP/dist;
            // Determine the orbit direction (clockwise/counter-clockwise) based on world position.
            const s = SIN((u.x+u.z)*.2)>0?1:-1;
            // Apply a force towards the player and a perpendicular force for orbiting.
            fx += nx*1.1 + (-nz*s)*3; fz += nz*1.1 + (nx*s)*3;
        // If the player is very close (distance < 10), the cat will flee.
        } else {
            // Apply a force directly away from the player.
            fx -= (dxP/dist)*5*(1+cat.caught*.4); fz -= (dzP/dist)*5*(1+cat.caught*.4);
        }

        // Calculate the cat's distance from the world origin.
        const dc = SQRT(cat.x*cat.x + cat.z*cat.z)||1;
        // If the cat is too far from the center (> 250), apply a strong force to bring it back.
        if(dc > 250){
            // The force increases the further away the cat is.
            //const k=(dc-150)*0.06;
            // Apply the centering force.
            fx += (-cat.x/dc*2); fz += (-cat.z/dc*2);
        // If the cat is too close to the center (< 30), apply a gentle force to push it away.
        }// else if(dc < 30){
        //    // Apply a gentle outward force.
        //    fx += (cat.x/dc)*0.5; fz += (cat.z/dc)*0.5;
        //}

        // Calculate the cat's current speed and direction for look-ahead checks.
        const spd = HYPOT(cat.vx, cat.vz) + .1, dirx = cat.vx/spd, dirz = cat.vz/spd;
        // 'look' is the distance ahead the cat will check for obstacles, scaled by its speed.
        const look = 10 + spd*.6;
        // Iterate through all obstacles in the scene.
        for(const ob of obstacles){
            // Calculate the vector from the cat to the obstacle.
            const ox = ob.x - cat.x, oz = ob.z - cat.z;
            // Define the avoidance radius (obstacle radius + a buffer).
            const rad = ob.r + 1.3;
            // Calculate the squared distance to the obstacle.
            const d2 = ox*ox + oz*oz;
            // If the cat is inside the avoidance radius, apply a strong repulsion force.
            if(d2 < rad*rad){
                // Normalize the repulsion vector.
                const d = SQRT(d2)||1;
                // Apply the repulsion force.
                fx -= (ox/d)*5*(1+cat.caught*.5); fz -= (oz/d)*5*(1+cat.caught*.5);
            // If the obstacle is within the look-ahead distance, perform a more precise check.
            } else if(d2 < look*look){
                // Project the obstacle's position onto the cat's forward vector.
                const ahead = ox*dirx + oz*dirz;
                // If the obstacle is in front of the cat and within the look-ahead distance...
                if(ahead>0 && ahead<look){
                    // Calculate the perpendicular distance from the cat's path to the obstacle.
                    const px = ox - dirx*ahead, pz = oz - dirz*ahead;
                    // Calculate the squared perpendicular distance.
                    const pd2 = px*px + pz*pz;
                    // If the perpendicular distance is less than the avoidance radius, a collision is imminent.
                    if(pd2 < rad*rad){
                        // Normalize the perpendicular vector.
                        const pd = SQRT(pd2)||1;
                        // Apply a steering force away from the obstacle.
                        fx -= (px/pd)*5*(1+cat.caught*.5); fz -= (pz/pd)*5*(1+cat.caught*.5);
                    }
                }
            }
        }

        // Evade impulse when very close
        cat.evade -= dt;
        if(dP2 < 9 && cat.evade<=0){ const d = SQRT(dP2)||1, nx = dxP/d, nz = dzP/d, s = RANDOM()<.5?1:-1; fx += (-nz*s)*50*(1+cat.caught*.2); fz += (nx*s)*50*(1+cat.caught*.2); cat.evade = .8 / SQRT(1 + cat.caught*.9); }

        // Integrate & clamp speed
        cat.vx += fx*dt; cat.vz += fz*dt;
        const maxS = cat.baseS + cat.caught*.5; let sp = HYPOT(cat.vx, cat.vz)||1;
        if(sp>maxS){ cat.vx = cat.vx/sp*maxS; cat.vz = cat.vz/sp*maxS; sp = maxS; }
        cat.x += cat.vx*dt; cat.z += cat.vz*dt;

        // Face movement direction
        if(sp>.1){
            const targetYaw = ATAN2(cat.vx, cat.vz); let dy = targetYaw - cat.yaw;
            if(dy > PI) dy -= 2*PI; else if(dy < -PI) dy += 2*PI; cat.yaw += dy * MIN(1, dt*10);
        }

        // Friction
        cat.vx *= (1 - 1.1*dt); cat.vz *= (1 - 1.1*dt);

        // Chase / drops
        const chased = dP2 < 120 ;/*&& playerMoveMag>.15;*/ chaseActive = chased;
        if(chased){ cat.drop -= dt; if(cat.drop<=0){ spawnDrop(cat.x, cat.z); cat.drop = 1.9 + RANDOM()*.8; } }

        // Anim & catch
        cat.anim += sp*dt*3.5;//3.5 radians per meter
        if(dP2 < 1/*(.5+CR)*(.5+CR)*/){
            cat.caught++; log('Cat caught #'+cat.caught/* +date.now */);
            if(audioCtx){ bell(audioCtx.currentTime,800,window.chipMusic,.5); bell(audioCtx.currentTime+.1,1000,window.chipMusic,.3); bell(audioCtx.currentTime+.2,1200,window.chipMusic,.4); }
            if(speedBoosts.length<10) speedBoosts.push({timeLeft:15, amount:.3});
            resetCatPosition();
        }
    }

    resetCatPosition();
    // -- /MODULE: Gameplay-Cat --

    function currentSpeedMult(){
        let m = 1;
        for (const b of speedBoosts) m += b.amount;
        return m;
    }

    function updateBoosts(dt){
        for (let i=speedBoosts.length-1;i>=0;i--){
            speedBoosts[i].timeLeft -= dt;
            if (speedBoosts[i].timeLeft<=0) speedBoosts.splice(i,1);
        }
    }

    function tryPickupItems(){
        // Closest point on capsule segment (vertical)
    const baseY = u.y - 1.6, topY = baseY + 1.6;
        for (const itm of items){
            if (!(itm.r>0)) continue;
            const ny = MAX(baseY, MIN(topY, itm.y));
            const dx = itm.x - u.x, dy = itm.y - ny, dz = itm.z - u.z;
            if (HYPOT(dx,dy,dz) < itm.r + .5){
                itm.r = 0; // mark consumed
                if (speedBoosts.length < 10) speedBoosts.push({ timeLeft: 15, amount: .3 });
                if(audioCtx) bell(audioCtx.currentTime, 880 * POW(2, ((RANDOM()*6)|0)/6), window.chipMusic, .2);
            }
        }
    }

    function resolveCollisions(prevX, prevZ){
        // Capsule vs sphere obstacles
    const baseY = u.y - 1.6, topY = baseY + 1.6;
        const hit = o => {
            const ny = MAX(baseY, MIN(topY, o.y));
            let dx = u.x - o.x, dy = ny - o.y, dz = u.z - o.z;
            const d = HYPOT(dx,dy,dz), minD = .5 + o.r;
            if (d < minD){
                if (d < .0001) { u.x = prevX; u.z = prevZ; }
                else { const p = (minD - d)/d; u.x += dx * p; u.z += dz * p; }
            }
        };
        for (const o of obstacles) hit(o);
        for (const o of traps) hit(o);
        // Ground collision (keep eye at least capsule height above 0)
    if (u.y - 1.6 < 0) u.y = 1.6;
    }
    // -- /MODULE: Gameplay-Items --

    // -- MODULE: Gameplay-Movement --
    // --- Movement Logic ---
    // Movement and input constants
    //const MOVES = 3;    // Movement speed in meters per second
    //const TURNS = 2;    // Turning speed in radians per second

    // Consolidates input from keyboard, joysticks, and VR controllers into a single movement vector
    function getMove(session) {
        let vx = 0, vy = 0, vt = 0;
        // -- SOLUTION: Gameplay-Movement-Keyboard --
        // Keyboard input (WASD for move, QE for turn)
    const kx = (+!!I.keys.d) - (+!!I.keys.a);
    const ky = (+!!I.keys.w) - (+!!I.keys.s);
    const kt = (+!!I.keys.q) - (+!!I.keys.e);
        // -- /SOLUTION: Gameplay-Movement-Keyboard --
    
        // -- SOLUTION: Gameplay-Movement-Joystick --
    // Virtual joystick input
    const jx = I.joy.L.x;
    const jy = -I.joy.L.y;
    const jt = -I.joy.R.x;
        // -- /SOLUTION: Gameplay-Movement-Joystick --

        // -- SOLUTION: Gameplay-Movement-VR --
        // VR gamepad input
        if (session) {
            for (const src of session.inputSources) {
                const a = src.gamepad?.axes;
                if (!a || a.length < 4) continue;
                const dz = v => ABS(v) > DZ ? v : 0; // Apply deadzone
                const x = dz(a[2]);
                const y = dz(a[3]);
                
                if (src.handedness === 'left') { vx = x; vy = -y; }
                else if (src.handedness === 'right') { vt = -x; }
                else if (!vx && !vy) { vx = x; vy = -y; } // Fallback for undefined handedness
            }
        }
        // -- /SOLUTION: Gameplay-Movement-VR --

        // Return combined movement, prioritizing VR, then keyboard, then joystick
        return { x: vx || kx || jx, y: vy || ky || jy, t: vt || kt || jt };
    }

    // -- SOLUTION: Gameplay-Movement-Step --
    // Updates the user's position and orientation based on movement input and delta time
    function step(dt, mv) {
        // New movement logic
        updateBoosts(dt);
        const speed = 3/*MOVES*/ * (currentSpeedMult());
        // Apply movement
        const now = performance.now();
        const moveMagnitude = HYPOT(mv.x, mv.y); playerMoveMag = moveMagnitude;
        // Trigger movement music activation (only sets flag / lazy init)
        if(moveMagnitude > .1 && now - lastStepTime > 500/*stepInterval*/){
            playStepSound(); // now activates loop system
            lastStepTime = now;
        }
    u.yaw += mv.t * 2/*TURNS*/ * dt; // Apply turning
        
        // Calculate forward and right vectors based on current yaw
    const cy = COS(u.yaw);
    const sy = SIN(u.yaw);
        T_V3_A[0] = -sy; T_V3_A[1] = 0; T_V3_A[2] = -cy; // 'f' vector
        T_V3_B[0] = cy;  T_V3_B[1] = 0; T_V3_B[2] = -sy;  // 'r' vector
        //const sp = MOVES * dt;
        const sp = speed * dt;
        // collision resolution
    const prevX = u.x, prevZ = u.z;

        // Apply movement along forward and right vectors
        u.x += (T_V3_B[0] * mv.x + T_V3_A[0] * mv.y) * sp;
        u.z += (T_V3_B[2] * mv.x + T_V3_A[2] * mv.y) * sp;
    // Update velocity using previous stored position
    userVelX = (u.x - prevUserX) / dt;
    userVelZ = (u.z - prevUserZ) / dt;
    prevUserX = u.x; prevUserZ = u.z;
        // Resolve collisions with obstacles
        resolveCollisions(prevX, prevZ);
        tryPickupItems();

    }
    // -- /SOLUTION: Gameplay-Movement-Step --
    // -- /MODULE: Gameplay-Movement --
    // -- /FEATURE: Gameplay --
    
    // -- FEATURE: Scene --
    // -- MODULE: Scene-Audio --
    // todo: implement stereo sources to get spatial audio (directional wind sound)
    let audioCtx = null;
    let lastStepTime = 0;
    //const stepInterval = 500; // ms between walking sounds
    // Global toggle for step/adaptive music sounds
    let music = true;
    
    function initAudio(){
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (!window.windPlaying) { window.windPlaying = true; playWindSound(); }

    }
    // -- SOLUTION: Scene-Audio-Wind --
    // Spatial wind (stereo ILD/ITD) with brown noise source
    function playWindSound(){
        if(!audioCtx) return;
        const N=audioCtx.sampleRate*3,b=audioCtx.createBuffer(1,N,audioCtx.sampleRate),d=b.getChannelData(0);
        let l=0;for(let i=0;i<N;i++){const w=RANDOM()*2-1;d[i]=l=(l+.01*w)/1.03;}
        const s=audioCtx.createBufferSource();s.buffer=b;s.loop=true;
        const f=audioCtx.createBiquadFilter();f.type='lowpass';f.frequency.value=200;f.Q.value=1.1;
        const lD=audioCtx.createDelay(.01), rD=audioCtx.createDelay(.01);
        const lG=audioCtx.createGain(), rG=audioCtx.createGain();
        const mix=audioCtx.createChannelMerger(2), m=audioCtx.createGain();
        s.connect(f);f.connect(lD);f.connect(rD);lD.connect(lG);rD.connect(rG);lG.connect(mix,0,0);rG.connect(mix,0,1);mix.connect(m);m.connect(audioCtx.destination);
        const t=audioCtx.currentTime;m.gain.setValueAtTime(0,t);m.gain.linearRampToValueAtTime(.2,t+4);s.start();
        audioCtx.windSource=s;audioCtx.windFilter=f;audioCtx.windMaster=m;audioCtx.windLeftGain=lG;audioCtx.windRightGain=rG;audioCtx.windLeftDelay=lD;audioCtx.windRightDelay=rD;
    }
    // gust & sway like grass shader
    function computeGustAt(x,z,t){const g=.6*SIN(x*.07+z*.05+t*.7)+.4*SIN(x*-.03+z*.04-t*1.2);return{gust:g,sway:.25*g+.07*SIN(t*1.7)};}
    // derive local flow dir from gradient
    function computeWindVector(x,z,t){const e=.5;const gX1=computeGustAt(x+e,z,t).gust,gX0=computeGustAt(x-e,z,t).gust,gZ1=computeGustAt(x,z+e,t).gust,gZ0=computeGustAt(x,z-e,t).gust;let gx=(gX1-gX0)/(2*e),gz=(gZ1-gZ0)/(2*e);let vx=-gz,vz=gx;const L=HYPOT(vx,vz)||1;vx/=L;vz/=L;const rot=.2*SIN(t*.05),cr=COS(rot),sr=SIN(rot);return{x:vx*cr-vz*sr,z:vx*sr+vz*cr,speed:L};}
    function updateWind(timeSec,camX,camZ,yaw){
        const ac=audioCtx;if(!ac||!ac.windMaster)return;const now=ac.currentTime;const s=computeGustAt(camX,camZ,timeSec);const w=computeWindVector(camX,camZ,timeSec);
        // loudness/brightness
        let g=.04+.3*s.sway;g=MAX(.01,MIN(1,g));ac.windMaster.gain.setTargetAtTime(g,now,.2);
        const freq=200+((s.sway+.32)/.64)*1200;ac.windFilter.frequency.setTargetAtTime(freq,now,.2);
        // stereo cues from relative angle
        const a=ATAN2(SIN(ATAN2(w.x,w.z)-yaw),COS(ATAN2(w.x,w.z)-yaw));const pan=SIN(a);
        const ild=.2;ac.windLeftGain.gain.setTargetAtTime(1-ild*pan,now,.15);ac.windRightGain.gain.setTargetAtTime(1+ild*pan,now,.1);
        const itd=.0007*pan;ac.windLeftDelay.delayTime.setTargetAtTime(itd>0?itd:0,now,.05);ac.windRightDelay.delayTime.setTargetAtTime(itd<0?-itd:0,now,.05);
    }
    // -- /SOLUTION: Scene-Audio-Wind --
    // -- SOLUTION: Scene-Audio-Click --
    function playClickSound(){
        if(!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, t);
        gain.gain.setValueAtTime(.3, t);
        gain.gain.exponentialRampToValueAtTime(.0001, t + .1);
        osc.start(t);
        osc.stop(t + .1);    
    }
    // -- /SOLUTION: Scene-Audio-Click --
    // -- SOLUTION: Scene-Audio-Step --
    function playStepSound(){
        if(!audioCtx) return; if(!window.chipMusic){
            const g=audioCtx.createGain();g.gain.value=0;g.connect(audioCtx.destination);
            // Patterns compressed as strings (k=kick,s=snare). Bells sequence digits / letters -> index, '_' = rest
            window.chipMusic={g,eng:0,last:audioCtx.currentTime,b0:90,b1:190,bd:60/140,next:audioCtx.currentTime+.05,st:0,
                k:"1.....1.1.1...1.",s:"....1.......1...", // spaces ignored
                //bl:"0_23_45_6_765_43210_35_642_10_7_".replace(/\s/g,''),
                //sc:[0,2,3,5,7,8,11,12]};
                //bl:"0_1_2_3_2_1_0_1_3_2_1_0_2_3_4_3_2_1_0_1_2_3_2_1_0_3_2_1_0_2_3_4_".replace(/\s/g,''),
                //sc:[0,2,4,5,7,9,11,12]};
                //bl:"0_23_45_6_765_43210_35_642_10_7_".replace(/\s/g,''),
                //sc:[0,2,3,5,7,8,11,12]};
                //bl:"0_1_2_1_0_3_2_1_0_4_2_1_0_5_2_1_".replace(/\s/g,''),
                //sc:[0,-1,2,3,5,7]};
                bl:"0_1_2_1_0___3_2_1_0___2_3_4_3_2_1_0___1_2_3_2_1_0___4_3_2___3_4_5_4_3___2_1_0___".replace(/\s/g,''),
                sc:[0,2,4,5,7,9]};
        }
    }
    function updateAdaptiveMusic(mv,dt){
        if(!audioCtx||!window.chipMusic)return;const m=window.chipMusic,now=audioCtx.currentTime;
        // base engagement rise only if moving AND either chasing or has boosts
        const boostLevel = speedBoosts.length; // 0..10 typical
        const boostFactor = MIN(1, boostLevel*.08); // up to +0.8 contribution
        const active = mv>.1 && (chaseActive || boostLevel>0);
        if(active){
            // faster build if actually chasing; slower if only boosts
            const build = (chaseActive?.08:.04) + .03*boostFactor;
            m.eng=MIN(1,m.eng+build*dt);m.last=now;
        } else if(now-m.last> (chaseActive?.6:.9)) {
            // decay slower when recently chasing
            const decay = chaseActive?.15:.10;
            m.eng=MAX(0,m.eng-decay*dt);
        }
        // tempo scaled also by boosts (slight) but clamp if not chasing (cap energy effect)
        const effEng = chaseActive?m.eng: m.eng*.6; // limit build when passive
        const tempoBoost = 1 + boostFactor*.25; // up to +25% at max boosts
        const tempo = (m.b0+(m.b1-m.b0)*POW(effEng,.7))*tempoBoost;
        m.bd=60/tempo;
        const baseGain = effEng?.05+.18*effEng:0;
        // small additive layer from boosts while chasing
        const tg = baseGain + (chaseActive?boostFactor*.05:0);
        m.g.gain.setTargetAtTime(tg,now,.25);
        while(music && now>=m.next){emitBeat(m);m.next+=m.bd/2;}
        if(m.eng===0&&now-m.last>5)m.g.gain.setTargetAtTime(.0001,now,1);
    }
    function emitBeat(m){const t=audioCtx.currentTime; m.st++;const i=m.st%16; // drums
        if(m.eng>.2 && m.k[i]==='1') kick(t,m);
        if(m.eng>.35&& m.s[i]==='1') snare(t,m);
        const b=m.bl[m.st % m.bl.length]; if(b!=='_'&&m.eng>.3){ const sem=m.sc[+b]||0; bell(t,980*POW(2,sem/12),m); }
    }
    function kick(t,m){if(!window.chipMusic)return;const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.type='sine';o.frequency.setValueAtTime(120,t);o.frequency.exponentialRampToValueAtTime(50,t+.18);g.gain.setValueAtTime(.001,t);g.gain.exponentialRampToValueAtTime(.2*(.4+.4*m.eng),t+.01);g.gain.exponentialRampToValueAtTime(.0001,t+.22);o.connect(g);g.connect(m.g);o.start(t);o.stop(t+.24);}    
    function snare(t,m){if(!window.chipMusic)return;const n=audioCtx.createBufferSource(),B=audioCtx.createBuffer(1,audioCtx.sampleRate*.18,audioCtx.sampleRate),d=B.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=(RANDOM()*2-1)*POW(1-i/d.length,1.8);n.buffer=B;const bp=audioCtx.createBiquadFilter();bp.type='bandpass';bp.frequency.value=1800;const g=audioCtx.createGain();g.gain.setValueAtTime(.001,t);g.gain.exponentialRampToValueAtTime(.35*(.4+.6*m.eng),t+.008);g.gain.exponentialRampToValueAtTime(.0001,t+.18);n.connect(bp);bp.connect(g);g.connect(m.g);n.start(t);n.stop(t+.18);}    
    function bell(t,f,m,vol){if(!window.chipMusic)return;const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.type='triangle';o.frequency.value=f;g.gain.setValueAtTime(.001,t);const pk=(vol||.18)*(.5+.2*m.eng);g.gain.exponentialRampToValueAtTime(pk,t+.02);g.gain.exponentialRampToValueAtTime(.0002,t+.55);o.connect(g);g.connect(m.g);o.start(t);o.stop(t+.6);}
    //function spawnCatVoice(t, f, m){
    //    // Simple formant-ish meow made from two detuned oscillators fading quickly
    //    const carrier = audioCtx.createOscillator();
    //    const formant = audioCtx.createOscillator();
    //    const g = audioCtx.createGain();
    //    carrier.type='square'; formant.type='sine';
    //    carrier.frequency.setValueAtTime(f, t);
    //    formant.frequency.setValueAtTime(f*2.01, t);
    //    // mild vibrato
    //    const lfo = audioCtx.createOscillator();
    //    const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 6; // semitone-ish wobble
    //    lfo.frequency.value = 5;
    //    lfo.connect(lfoGain); lfoGain.connect(carrier.frequency);
    //    g.gain.setValueAtTime(0.001,t);
    //    g.gain.exponentialRampToValueAtTime(0.1*(0.2+0.4*m.energy), t+0.05);
    //    g.gain.exponentialRampToValueAtTime(0.0003, t+0.55);
    //    carrier.connect(g); formant.connect(g); g.connect(m.g);
    //    carrier.start(t); formant.start(t); lfo.start(t);
    //    carrier.stop(t+0.6); formant.stop(t+0.6); lfo.stop(t+0.6);
    //}
    // -- /SOLUTION: Scene-Audio-Step --
    // -- /MODULE: Scene-Audio --

    // -- MODULE: Scene-HUD --
    // --- Log and HUD UI State ---
    const LOG = [];
    //const LOG_MAX = 200;
    let logScroll = 0;
    //let logVisible = true;
    let hudVisible = true;
    let congratsTimer = 0;
    let lastCaughtShown = 0;

    // State for HUD interaction.
    let HUD_WH_world = M4(); // World matrix of the HUD quad
    let hoverBtn = null; // The button currently being hovered over

    function log(s) { LOG.push(s); if (LOG.length > 200) LOG.shift(); }
    //function logClear() { LOG.length = 0; log('log cleared'); }

    // UI button definitions. Each object defines a button's ID, position (in UV space), label, and click handler
    let uiEnterLabel = 'Enter VR';
    const UI_MAIN = [
    { id: 'reset', u0: .4, v0: .05, u1: .7, v1: .15, label: 'Reset', onClick: () => { playClickSound(); u.x = 0; u.z = 2; u.yaw = 0; u.pitch = .2; resetCatPosition(); /*log('reset position');*/ } },
        { id: 'vr', u0: .4, v0: .2, u1: .7, v1: .3, label: () => uiEnterLabel, onClick: () => { playClickSound(); toggleXRFromUI(); } },
        { id: 'mmo', u0: .4, v0: .35, u1: .7, v1: .45, label: () => 'MMO: ' + (mmoEnabled ? 'ON' : 'OFF'), onClick: () => { playClickSound(); toggleMMO(); } },
        { id: 'music', u0: .8, v0: .35, u1: .98, v1: .45, label: () => 'Music: ' + (music ? 'ON' : 'OFF'), onClick: () => { playClickSound(); music = !music; log('music ' + (music ? 'on' : 'off')); } },
        //{ id: 'logtog', u0: 0.85, v0: 0.5, u1: 0.98, v1: 0.6 , label: 'LOG', onClick: () => { playClickSound(); logVisible = !logVisible; } },
        { id: 'logdn', u0: .85, v0: .8, u1: .98, v1: .9, label: 'Down', onClick: () => { playClickSound(); logScroll = MAX(0, logScroll - 1); } },
        { id: 'logup', u0: .85, v0: .7, u1: .98, v1: .8, label: 'Up', onClick: () => { playClickSound(); logScroll = MIN(MAX(0, LOG.length - 1), logScroll + 1); } },
        { id: 'hudx', u0: .8, v0: .04, u1: .98, v1: .2, label: 'Close       X', onClick: () => { playClickSound(); hudVisible = false; } }
    ];
    const UI_TAB = [
        { id: 'hudopen', u0: .4, v0: 0, u1: .6, v1: .12, label: 'HUD', onClick: () => { playClickSound(); hudVisible = true; } }
    ];

    // Returns the currently active set of UI buttons
    function currentUI() { return hudVisible ? UI_MAIN : UI_TAB; }

    // Returns the correct local transform for the HUD based on its visibility state
    function getHudTransform() {
        if (hudVisible) { // Centered panel
            return new DOMMatrix([1,0,0,0, 0,1,0,0, 0,0,1,0, 0, -.05, -1.15, 1]).toFloat32Array();
        }
        // Top tab.
        return new DOMMatrix([1,0,0,0, 0,1,0,0, 0,0,1,0, 0, .5, -1.15, 1]).toFloat32Array();
    }

    // --- HUD Interaction Needs Input-ray ---
    function HUD_pick(WH, ray, uiSet) {
        const ui = uiSet || currentUI();
        const inv = INV(WH);
        const o = mulPoint(inv, ray.o); // Transform ray to HUD's local space
        const d = mulDir(inv, ray.d);
        const t = -o[2] / d[2]; // Intersect with the Z=0 plane
        if (t <= 0) return null;

        const x = o[0] + d[0] * t;
        const y = o[1] + d[1] * t;

        // Check if the hit is within the quad's bounds
        if (x < -.26 || x > .26 || y < -.15 || y > .15) return null;
        
        // Convert local coordinates to UV coordinates
        const u = (x + .26) / (.26 * 2);
        const v = (.15 - y) / (.15 * 2);

        // Check against each button's UV bounds
        for (const b of ui) {
            if (u >= b.u0 && u <= b.u1 && v >= b.v0 && v <= b.v1) {
                return { id: b.id, u, v, button: b, t };
            }
        }
        return { id: null, u, v, button: null, t }; // Hit the panel but not a button
    }

    // --- HUD Drawing ---
    // Draws the entire HUD onto the 2D canvas
    function drawHUDCanvas(mode, hit, uiSet, dt) {
        const ui = uiSet || currentUI();
        hudCtx.clearRect(0, 0, hudCan.width, hudCan.height);

        if (!hudVisible) {
            // Draw the small "HUD" tab at the top of the screen
            const b = ui[0];
            const x = b.u0 * hudCan.width,
                  y = b.v0 * hudCan.height,
                  w = (b.u1 - b.u0) * hudCan.width,
                  h = (b.v1 - b.v0) * hudCan.height;
            const hov = hoverBtn && hoverBtn.id === 'hudopen';
            hudCtx.fillStyle = hov ? 'rgba(160,200,160,.3)' : 'rgba(120,160,120,.2)';
            hudCtx.strokeStyle = hov ? 'rgba(190,220,190,.9)' : 'rgba(160,200,160,.3)';
            hudCtx.lineWidth = 2;
            hudCtx.beginPath();
            hudCtx.roundRect(x, y, w, h, 10);
            hudCtx.fill();
            hudCtx.stroke();
            hudCtx.fillStyle = hov ? '#fff' : '#eef';
            hudCtx.font = '16px system-ui';
            hudCtx.textAlign = 'center';
            hudCtx.textBaseline = 'middle';
            hudCtx.fillText('HUD', x + w / 2, y + h / 2);
            hudCtx.textAlign = 'left';
            hudCtx.textBaseline = 'alphabetic';
        } else {
            // Draw the full HUD panel
            hudCtx.fillStyle = 'rgba(40,30,20,.8)';
            hudCtx.strokeStyle = 'rgba(160,200,160,.3)';
            hudCtx.lineWidth = 2;
            hudCtx.beginPath();
            hudCtx.roundRect(6, 6, hudCan.width - 12, hudCan.height - 12, 16);
            hudCtx.fill();
            hudCtx.stroke();

            // Header text
            hudCtx.fillStyle = '#9f9';
            hudCtx.font = '24px system-ui';
            hudCtx.fillText('HUD', 20, 34);
            hudCtx.fillStyle = '#fff';
            hudCtx.font = '16px system-ui';
            //hudCtx.fillText(`Mode: ${mode}${isMobile ? ' Touch' : ''}`, 20, 60);
            //hudCtx.fillText(`FPS: ${ROUND(1/dt)}`, 20, 80);// if xr active show multiple
            //hudCtx.fillText(`FPS: ${ROUND(1/dt)}`, 120, 40);// if xr active show multiple
            //hudCtx.fillText(`MS: ${dt.toFixed(3)}`, 100, 80);// if xr active, show
            //hudCtx.fillText(`Pos: (${u.x.toFixed(1)}, ${u.z.toFixed(1)})`, 100, 100);
            //hudCtx.fillText(`Yaw: ${(u.yaw * 180 / PI | 0)}¬∞`, 20, 100);
            //hudCtx.fillText(`Cat Caught: ${cat.caught}`, 20, 120);
            //hudCtx.fillText(`Boosts: ${speedBoosts.length}`, 150, 120);
            hudCtx.fillText(`Boosts: ${speedBoosts.length}`, 20, 70);
            hudCtx.fillText(`Cat Caught: ${cat.caught}`, 20, 100);
            // MMO status line
            const peerCount = (function(){ let n=0; try{ peers.forEach((p,id)=>{ if(id!==myId && performance.now() - (p.last||0) < 15000) n++; }); }catch(_){} return n; })();
            //hudCtx.fillText(`MMO: ${mmoEnabled ? (myId? 'ON':'CONNECTING') : 'OFF'}  Peers: ${peerCount}`, 20, 140);
            hudCtx.fillText(`MMO: ${mmoEnabled ? 'ON' : 'OFF'}  Peers: ${peerCount}`, 20, 130);
            //if (hit) { hudCtx.fillStyle = '#afa';
            //hudCtx.fillText(`Hit @ ground: (${hit[0].toFixed(2)}, ${hit[2].toFixed(2)})`, 20, 140); }

            // Log box
            //if (logVisible) {
                const x = 20,
                      y = 160,
                      w = hudCan.width - 130,
                      h = hudCan.height - 180;
                hudCtx.fillStyle = 'rgba(0,0,0,.4)';
                hudCtx.strokeStyle = 'rgba(160,200,160,.3)';
                hudCtx.beginPath();
                hudCtx.roundRect(x, y, w, h, 10);
                hudCtx.fill();
                hudCtx.stroke();
                hudCtx.save();
                hudCtx.beginPath();
                hudCtx.rect(x + 8, y + 8, w - 16, h - 16);
                hudCtx.clip();
                hudCtx.fillStyle = '#eee';
                hudCtx.font = '14px ui-monospace, system-ui';
                const lines = LOG.slice(MAX(0, LOG.length - 8 - logScroll), LOG.length - logScroll);
                //const lines = LOG.slice(MAX(0, LOG.length - 8), LOG.length);
                for (let i = 0; i < lines.length; i++)
                    hudCtx.fillText(lines[i], x + 12, y + 14 + i * 16);
                hudCtx.restore();
            //}

            // Buttons
            for (const b of UI_MAIN) {
                const lab = (typeof b.label === 'function') ? b.label() : b.label;
                const x = b.u0 * hudCan.width,
                      y = b.v0 * hudCan.height,
                      w = (b.u1 - b.u0) * hudCan.width,
                      h = (b.v1 - b.v0) * hudCan.height;
                const hov = hoverBtn && hoverBtn.id === b.id;
                hudCtx.fillStyle = hov ? 'rgba(150,190,150,.2)' : 'rgba(120,160,120,.1)';
                hudCtx.strokeStyle = hov ? 'rgba(190,220,190,.9)' : 'rgba(160,200,160,.3)';
                hudCtx.lineWidth = 1;
                hudCtx.beginPath();
                hudCtx.roundRect(x, y, w, h, 8);
                hudCtx.fill(); hudCtx.stroke();
                hudCtx.fillStyle = hov ? '#fff' : '#eef';
                hudCtx.font = '18px system-ui';
                //hudCtx.textAlign = 'center';
                hudCtx.textBaseline = 'middle';
                //hudCtx.fillText(lab, x + w / 2, y + h / 2);
                //hudCtx.textAlign = 'left';
                // Center text vertically and with a slight left padding
                hudCtx.fillText(lab, x + 10, y + h * .5);
            }
        }
        // --- Third HUD variant: temporary overlay on top (minimal) ---
        if (congratsTimer > 0) {
            hudCtx.save();
            // Smooth fade near the end
            const alpha = (congratsTimer > .5) ? 1 : MAX(0, congratsTimer / .5);
            hudCtx.globalAlpha = alpha;
            // Position (clean, unobtrusive near upper center)
            const x = hudCan.width * .5 + 10;
            const y = hudCan.height * .4;
            const text = `CAT #${cat.caught} CAUGHT`;
            // Typography
            hudCtx.textAlign = 'center';
            hudCtx.textBaseline = 'middle';
            hudCtx.font = 'bold 44px system-ui';
            // Gentle vertical gradient fill
            const g = hudCtx.createLinearGradient(0, y - 10, 0, y + 10);
            g.addColorStop(0, '#c0e0f0'); // bluish top
            g.addColorStop(1, '#e0d0a0'); // yellowish bottom
            // Thin soft stroke for readability
            hudCtx.lineWidth = 7;
            hudCtx.strokeStyle = 'rgba(0,0,0,.5)';
            hudCtx.strokeText(text, x, y);
            hudCtx.fillStyle = g;
            hudCtx.fillText(text, x, y);
            // Text below
            //hudCtx.strokeText('Can you catch again?', x, y + 60);
            //hudCtx.fillText('Can you catch again?', x, y + 60);
            hudCtx.strokeText(`${13-cat.caught} Cats left to catch`, x, y + 60);
            hudCtx.fillText(`${13-cat.caught} Cats left to catch`, x, y + 60);
            // if cat.caught = 4 write additional text
            //if (cat.caught === 4 || cat.caught === 6) {
            //    hudCtx.strokeText('Cat is getting faster!', x, y + 120);
            //    hudCtx.fillText('Cat is getting faster!', x, y + 120);
            //};
            //if (cat.caught === 9) {
            //    hudCtx.strokeText('Nine lives fading!', x, y + 120);
            //    hudCtx.fillText('Nine lives fading!', x, y + 120);
            //};
            if (cat.caught === 13) {
                lastCaughtShown = cat.caught;
                hudCtx.strokeText('Victory! You win!', x, y + 120);
                hudCtx.fillText('Victory! You win!', x, y + 120);
            };


            hudCtx.restore();
        }

        // Upload the canvas content to the WebGL texture
        gl.bindTexture(gl.TEXTURE_2D, hudTex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, hudCan);
    }

    
    // --- HUD Shader ---
    // The HUD is a 2D canvas drawn in the DOM, then uploaded to a WebGL texture to be displayed on a 3D quad

    let hudTex = gl.createTexture();
    let hudCan = document.createElement('canvas');
    let hudCtx = hudCan.getContext('2d');
    hudCan.width = 640;
    hudCan.height = 320;

    gl.bindTexture(gl.TEXTURE_2D, hudTex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // Simple textured quad shader for the HUD (unified MVP)
    const vsMVP = `layout(location=0)in vec3 p;layout(location=1)in vec2 uv;uniform mat4 M,V,P;out vec2 f;out vec3 W;void main(){vec4 wpos=M*vec4(p,1.);W=wpos.xyz;f=uv;gl_Position=P*V*wpos;}`;
    const fsH = `in vec2 f;uniform sampler2D T;out vec4 o;void main(){vec4 c=texture(T,f);if(c.a<.01)discard;o=c;}`;
    const PH = prog(vsMVP, fsH);
    const uMH = gl.getUniformLocation(PH, 'M'),
          uVH = gl.getUniformLocation(PH, 'V'),
          uPH = gl.getUniformLocation(PH, 'P'),
          uT = gl.getUniformLocation(PH, 'T');

    const vboH = gl.createBuffer(), vaoH = gl.createVertexArray();
    gl.bindVertexArray(vaoH);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboH);
    // Vertex data for the HUD quad (position and UV coordinates).
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-.26,.15,0, 0,1,  .26,.15,0, 1,1,  .26,-.15,0, 1,0,  -.26,.15,0, 0,1,  .26,-.15,0, 1,0,  -.26,-.15,0, 0,0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0); 
    gl.vertexAttribPointer(0, 3, 
    gl.FLOAT, false, 20, 0);
    gl.enableVertexAttribArray(1); 
    gl.vertexAttribPointer(1, 2, 
    gl.FLOAT, false, 20, 12);

    // -- /MODULE: Scene-HUD --
    // -- MODULE: Scene-Sky --
    // --- Sky Shader ---
    let noiseTex = gl.createTexture();
    //let cloudCoverage = 0.25;      // threshold knob -> more/less cloud
    //let cloudSharpness = 0.52;     // edge softness knob
    //let shadowSamples = 3;        // cheap self-shadow sampling count
    //let cloudHeight = 100.0;      // height (world units) of the cloud layer (controls horizon)
    //let cloudScale = 0.0001;      // global mapping scale from world XZ -> cloud texture space (MAIN SIZE LEVER)
    //let cloudMotionSpeed = 0.02;   // global motion speed scalar

    function makeTileableNoise(size) {

        const n = size|0;
        // make a small random grid then bilinearly sample with wrap to create smooth tileable texture
        const grid = new Float32Array(n * n);
        for (let i = 0; i < grid.length; i++) grid[i] = RANDOM();

        // bilinear sampling helper with wrap
        function sampleGrid(u, v) {
            const x = u * n;
            const y = v * n;
            const x0 = ((x|0) + n) % n;
            const y0 = ((y|0) + n) % n;
            const x1 = (x0 + 1) % n;
            const y1 = (y0 + 1) % n;
            const fx = x - FLOOR(x);
            const fy = y - FLOOR(y);
            const a = grid[y0 * n + x0];
            const b = grid[y0 * n + x1];
            const c = grid[y1 * n + x0];
            const d = grid[y1 * n + x1];
            const ab = a * (1 - fx) + b * fx;
            const cd = c * (1 - fx) + d * fx;
            return ab * (1 - fy) + cd * fy;
        }

        const img = new Uint8Array(n * n * 4);
        for (let y = 0; y < n; y++) {
            for (let x = 0; x < n; x++) {
                const u = (x + .5) / n;
                const v = (y + .5) / n;
                // sample at multiple fractional offsets then combine to get smoother noise
                const v0 = sampleGrid(u, v);
                const v1 = sampleGrid(u + .5 / n, v + .3 / n);
                const val = MAX(0, MIN(1, (v0 * .6 + v1 * .4)));
                const idx = (y * n + x) * 4;
                const c = (val * 255) | 0;
                img[idx + 0] = c;
                img[idx + 1] = c;
                img[idx + 2] = c;
                img[idx + 3] = 255;
            }
        }

        gl.bindTexture(gl.TEXTURE_2D, noiseTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    // Try: makeTileableNoise(256) or (512) for crisper small-scale details (optional)
    makeTileableNoise(128);

    // A procedural skybox rendered using a single full-screen triangle
    const vsSky=`const vec2 v[3]=vec2[3](vec2(-1,-1),vec2(3,-1),vec2(-1,3));out vec2 a;void main(){a=v[gl_VertexID]*.5+.5;gl_Position=vec4(v[gl_VertexID],0,1);}`;

    // Replaced fragment shader: perspective-correct cloud mapping, reduced velocities, minified identifiers
    const fsSky=`in vec2 a;out vec4 b;uniform mat4 c,d;uniform sampler2D e;uniform float f;float g(vec2 p){return texture(e,p).r;}float h(vec2 p){float s=0.,A=.5;s+=A*g(p+f*vec2(.012,.007)*.02);p*=2.;A*=.5;s+=A*g(p+f*vec2(-.008,.015)*.02);p*=2.;A*=.5;s+=A*g(p+f*vec2(.017,-.011)*.02);p*=2.;A*=.5;s+=A*g(p+f*vec2(-.011,-.018)*.02);return s;}void main(){vec3 i=(c*vec4(0,0,0,1)).xyz;vec4 j=d*vec4(a*2.-1.,1,1);vec3 k=normalize(j.xyz/j.w-i);float l=pow(max(k.y*.5+.5,0.),1.2);vec3 m=mix(vec3(.2,.28,.36),vec3(.2,.2,.4),l);vec3 n=normalize(vec3(.1,.1,-.9));float o=max(dot(k,n),0.);float p=smoothstep(.995,1.,o);m+=vec3(.8,.6,.1)*(pow(o,60.)+.4*pow(o,12.))+vec3(1)*p*.15;vec2 q;float r=(100.-i.y)/k.y;if(r>0.){vec3 C=i+k*r;q=C.xz;}else{vec3 C=i+k*1000.;q=C.xz;}vec2 s=q*.0001;float t=h(s);float u=smoothstep(.25,.25+.52,t);vec2 v=normalize(n.xz+.0001);float w=0.;for(int B=1;B<=3;++B){vec2 C=s+v*float(B)*8e-4;w+=h(C);}w/=3.;float x=1.-clamp(w*1.6,0.,1.);vec3 y=vec3(.95,.98,1.)*(.45+.55*x);y+=.25*p*clamp(dot(n,k),0.,1.);m=mix(m,y,u*.95);b=vec4(m,1.);}`;

    const PSKY = prog(vsSky, fsSky);
    const vaoSky = gl.createVertexArray();
    const uVinv = gl.getUniformLocation(PSKY, 'c');
    const uInvPV = gl.getUniformLocation(PSKY, 'd');
    //const uSun = gl.getUniformLocation(PSKY, 'sunDir');

    // --- new: sky shader uniform locations for noise & cloud params ---
    const uNoiseSky = gl.getUniformLocation(PSKY, 'e');
    const uTimeSky = gl.getUniformLocation(PSKY, 'f');
    //const uCoverage = gl.getUniformLocation(PSKY, 'uCloudCoverage');
    //const uSharpness = gl.getUniformLocation(PSKY, 'uCloudSharpness');
    //const uShadowSamples = gl.getUniformLocation(PSKY, 'uCloudShadowSamples');
    //const uCloudHeightLoc = gl.getUniformLocation(PSKY, 'uCloudHeight');
    //const uCloudScaleLoc = gl.getUniformLocation(PSKY, 'uCloudScale');
    //const uCloudMotionSpeedLoc = gl.getUniformLocation(PSKY, 'uCloudMotionSpeed');

    // -- /MODULE: Scene-Sky --
    // -- MODULE: Scene-Ground --
    // --- Grid Shader ---
    // A simple shader to draw a grid on the ground plane
    const fsG=`in vec3 W;out vec4 o;float h(vec2 v){return fract(sin(dot(v,vec2(41,289)))*9e3);}void main(){vec2 q=floor(W.xz/.6);float r=h(q),r2=h(q+13.);o=vec4(mix(vec3(.08,.05,.02),vec3(.3,.2,.1),r)+step(.97,r2)*vec3(.1,.08,.04),1);}`;

    const PG = prog(vsMVP, fsG);
    const uM = gl.getUniformLocation(PG, 'M');
    const uV = gl.getUniformLocation(PG, 'V');
    const uP = gl.getUniformLocation(PG, 'P');
    const vbo = gl.createBuffer();
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    // A large quad to serve as the ground plane.
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1000,0,-1000, 1000,0,-1000, 1000,0,1000, -1000,0,-1000, 1000,0,1000, -1000,0,1000]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    // -- /MODULE: Scene-Ground --
    
    // -- MODULE: Gameplay-item --
    // NEW: Sphere (items/obstacles) minimal shader + geometry
    // Reuse vsMVP by passing model matrix with translate+scale
    const fsSphere = `uniform vec3 c;out vec4 o;void main(){ o = vec4(c,1.); }`;

    function buildSphere(lat=10, lon=12){
        const v=[];
        for(let i=0;i<lat;i++){
            const t1=PI*i/lat, t2=PI*(i+1)/lat;
            for(let j=0;j<lon;j++){
                const p1=2*PI*j/lon, p2=2*PI*(j+1)/lon;
                const quad=[
                    sph(t1,p1),sph(t2,p1),sph(t2,p2),
                    sph(t1,p1),sph(t2,p2),sph(t1,p2)
                ];
                for(const q of quad) v.push(q[0],q[1],q[2]);
            }
        }
        return new Float32Array(v);
    }
    function sph(t,p){ return [SIN(t)*COS(p), COS(t), SIN(t)*SIN(p)]; }

    const PS = prog(vsMVP, fsSphere);
    const sphereVao = gl.createVertexArray();
    const sphereBuf = gl.createBuffer();
    gl.bindVertexArray(sphereVao);
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuf);
    const sphereVerts = buildSphere();
    gl.bufferData(gl.ARRAY_BUFFER, sphereVerts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
    const uS_M = gl.getUniformLocation(PS,'M');
    const uS_V = gl.getUniformLocation(PS,'V');
    const uS_P = gl.getUniformLocation(PS,'P');
    const uS_Color = gl.getUniformLocation(PS,'c');

    // -- /MODULE: Gameplay-item --

    // -- MODULE: Scene-Rocks --
    // Stylized low-poly rocks: deterministic placement, flat-ish shading, and collision integration
    const rocks = []; // currently active rock descriptors {x,y,z,r,seed}

    // Simple deterministic hash for rock placement
    function rockHash(ix, iz, salt){
        const s = SIN(ix*127.1 + iz*311.7 + salt*13.13) * 43758.5453;
        return s - FLOOR(s);
    }

    // Build a low-res sphere for rock base (coarse facets)
    const rockVerts = buildSphere(6, 8); // fewer subdivisions -> larger facets
    const PRock_vs = `layout(location=0)in vec3 p;uniform mat4 V,P;uniform vec3 a;uniform float b,c;out vec3 d;float h(float x){return fract(sin(x)*43758.5453);}void main(){d=p*b;float n=h((d.x+d.y*1.7+d.z*2.3)*(c+1.));float o=(n-.5)*(.5*b);vec3 w=(d+normalize(d)*o)+a;gl_Position=P*V*vec4(w,1.);}`;

    const PRock_fs = `in vec3 d;out vec4 o;void main(){vec3 n=normalize(d+vec3(0.,0.,-2.5));float s=clamp(dot(n,normalize(vec3(0.,.1,-.5))),0.,1.);float q=floor(s*4.)/4.;vec3 c=mix(vec3(.15,.1,.1),vec3(.35,.3,.2),q);o=vec4(c,1.);}`;

    const PROCK = prog(PRock_vs, PRock_fs);
    const rockVao = gl.createVertexArray();
    const rockBuf = gl.createBuffer();
    gl.bindVertexArray(rockVao);
    gl.bindBuffer(gl.ARRAY_BUFFER, rockBuf);
    gl.bufferData(gl.ARRAY_BUFFER, rockVerts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    const uR_V = gl.getUniformLocation(PROCK, 'V');
    const uR_P = gl.getUniformLocation(PROCK, 'P');
    const uR_Pos = gl.getUniformLocation(PROCK, 'a');
    const uR_S = gl.getUniformLocation(PROCK, 'b');
    const uR_Seed = gl.getUniformLocation(PROCK, 'c');
    // -- /MODULE: Scene-Rocks --

    // -- MODULE: Scene-Grass --
    // --- Grass Shaders ---
    // Uses instanced rendering to draw many blades of grass efficiently
    const vsGrass=`uniform mat4 V,P;uniform vec2 c;uniform vec3 r;uniform float d,a;uniform int n;uniform float s;uniform sampler2D e;out vec3 uCol;float h12(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);}vec2 h22(vec2 p){float x=sin(dot(p,vec2(1.,113.)));return fract(vec2(262144.*x,32768.*x));}void main(){int iid=gl_InstanceID;vec2 camCellF=floor(c/a);vec2 cellF=camCellF+vec2(float(iid % n - n/2),float(iid / n - n/2));vec2 baseCenter=(cellF+vec2(.5))*a;vec2 tileKey=floor(baseCenter/a)+vec2(s);float biome=texture(e,baseCenter*.0002).r;float H=mix(.6,.9,h12(tileKey*3.1));float t=float(gl_VertexID/2)/4.;float side=(gl_VertexID%2==0)?-1.:1.;float width=.05*(1.-t)*(.6+.6*h12(tileKey*7.7))*1.45;float gust=.6*sin(dot(baseCenter,vec2(.07,.05))+d*.7)+.4*sin(dot(baseCenter,vec2(-.03,.04))-d*1.2);float sway=.25*gust+.07*sin(d*1.7+h12(tileKey*5.3)*6.2831853);float bend=(t*t)*sway;vec2 baseXZ=baseCenter+(h22(tileKey)-.5)*(a*90.9);vec2 w=vec2(cos(.3*d),sin(.32*d));w*=inversesqrt(dot(w,w)+.001);vec2 windDir=w;vec3 bendOff=vec3(windDir.x,0.,windDir.y)*bend*H;vec3 pos=vec3(baseXZ.x,0.,baseXZ.y)+normalize(r)*(side*width)+vec3(0.,t*H,0.)+bendOff;vec3 c0=mix(vec3(.12,.10,.01),vec3(.05,.12,.02),biome);vec3 c1=mix(vec3(.45,.38,.05),vec3(.30,.70,.22),biome);uCol=mix(c0,c1,smoothstep(0.,1.,t))*(.85+.15*h12(tileKey*11.1));gl_Position=P*V*vec4(pos,1.);}`;
    const fsGrass = `in vec3 uCol;out vec4 o;void main(){ o = vec4(uCol, 1.0); }`;
    //const fsGrass = `in vec3 h;out vec4 o;void main(){ o = vec4(h, 1.); }`;
    const PGRASS = prog(vsGrass, fsGrass);
    const uVG = gl.getUniformLocation(PGRASS, 'V'), uPG = gl.getUniformLocation(PGRASS, 'P');
    const uCamXZ = gl.getUniformLocation(PGRASS, 'c');
    const uCamRight = gl.getUniformLocation(PGRASS, 'r');
    const uTimeG = gl.getUniformLocation(PGRASS, 'd');
    const uCell = gl.getUniformLocation(PGRASS, 'a');
    const uGridN = gl.getUniformLocation(PGRASS, 'n');
    const uSeed = gl.getUniformLocation(PGRASS, 's');
    const uNoise = gl.getUniformLocation(PGRASS, 'e');

    // The grass VAO is minimal since all vertex data is generated procedurally in the shader
    const vaoGrass = gl.createVertexArray(), vboGrass = gl.createBuffer();
    gl.bindVertexArray(vaoGrass);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboGrass);
    gl.bufferData(gl.ARRAY_BUFFER, new F32([0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);

    // -- /MODULE: Scene-Grass --
    // -- MODULE: Scene-Plant --
    // --- L-System Plant Shader ---
    // -- SOLUTION: Scene-Plant--
    // Positions and scales for the scattered L-system plants.
    // --- Procedural plant field (infinite-style) ---
    //const PLANT_CELL = 6.0;          // World size of one plant decision cell
    //const PLANT_PROB = 0.3;         // Spawn probability per cell
    //const PLANT_RADIUS = 55.0;       // Active radius around camera (render window)
    //const PLANT_SCALE_MIN = 1.8;
    //const PLANT_SCALE_MAX = 3.0;
    
    // Fast small hash (deterministic)
    function plantHash(ix, iz, salt){
        const s = SIN(ix*127.1 + iz*311.7 + salt*17.17)*43758.5453;
        return s - FLOOR(s);
    }
    
    // Generate plants near (cx,cz); returns array of objects
    function genPlants(cx, cz, fr){
        //const r = PLANT_RADIUS;
        //const c = 6.0;
        const minX = FLOOR((cx - fr)/6.);
        const maxX = FLOOR((cx + fr)/6.);
        const minZ = FLOOR((cz - fr)/6.);
        const maxZ = FLOOR((cz + fr)/6.);
        const out = [];
        for(let gz=minZ; gz<=maxZ; gz++){
            for(let gx=minX; gx<=maxX; gx++){
                const h = plantHash(gx, gz, .0);
                if(h < .3){
                    // Stable jitter inside cell
                    const jx = plantHash(gx, gz, 1.) - .5;
                    const jz = plantHash(gx, gz, 2.) - .5;
                    const px = gx*6. + (jx * 6. * .85) + 6.*.5;
                    const pz = gz*6. + (jz * 6. * .85) + 6.*.5;
                    const dx = px - cx, dz = pz - cz;
                    if(dx*dx + dz*dz <= fr*fr){
                        const sc = 1.8 + (plantHash(gx, gz, 3.) * (3 - 1.8));
                        out.push({px, pz, scale: sc, gx, gz});
                    }
                }
            }
        }
        return out;
    }

    //let cachedPlants = [];
    //let lastPlantCamX = 0, lastPlantCamZ = 0;
    
    const fsPlants=`in vec2 f;out vec4 o;uniform float g;uniform int h;uniform vec3 i;uniform float j;mat3 R(float a){float c=cos(a),s=sin(a);return mat3(vec3(c,s,0),vec3(-s,c,0),vec3(0,0,1));}mat3 D(vec2 d){return mat3(vec3(1,0,0),vec3(0,1,0),vec3(d,1));}float C(vec2 p,vec2 h){p-=vec2(0.,h.y);vec2 d=abs(p)-h;return min(max(d.x,d.y),0.)+length(max(d,0.));}float k(float x){return fract(sin(x)*43758.5453);}float l(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}float E(vec2 p){float m=25.7+j*10.;mat3 n=R(-m*.01745),q=R(m*.01745);int r=3+int(j*4.),s=1;for(int a=0;a<r;a++)s*=3;float t=1.5,u=.002;p+=vec2(0,2);float v=C(p,vec2(u,t)),w=1e9;int x=0;vec2 y=vec2(.07,.05),z=vec2(-.03,.04);float A=.6*sin(dot(i.xz,y)+g*.7)+.4*sin(dot(i.xz,z)-g*1.2);float F=fract(sin(dot(i.xz,vec2(12.9898,78.233)))*43758.5453)*6.283;float G=.25*A+.07*sin(g*1.7+F);mat3 H=R(G*.5);for(int a=0;a<h;++a){int I=s;vec2 J=p;for(int j=1;j<=r;++j){float K=t/exp2(float(j));I/=3;int L=x/I;int M=L-3*(L/3);mat3 N;if(M==0)N=n*D(vec2(0,-2.*K));else if(M==1)N=H*q*D(vec2(0,-2.*K));else N=H*D(vec2(0,-4.*K));J=(N*vec3(J,1)).xy;float O=C(J,vec2(u,K));if(O>2.*K){x+=I-1;break;}w=min(w,O);if(w<.01)break;}if(w<.01||++x>s)break;}return min(w,v);}void main(){vec2 p=(f*2.-1.)*5.;p.y+=3.;if(E(p)>.038)discard;float P=clamp(f.y,0.,1.),T=k(j*37.17),U=.85+.3*l(i.xz+vec2(j));vec3 Q=vec3(.3,.4,.1),S=vec3(.5,.4,.2),b=mix(Q,S,smoothstep(0.,1.,T));vec3 c=mix(b*.4,b,smoothstep(0.,1.,P))*U;c*=.97+.06*l(i.xz+f*12.34);o=vec4(c,1);}`; 

    const PPLANTS = prog(vsMVP, fsPlants); // Use unified vertex shader
    const uMPla = gl.getUniformLocation(PPLANTS, 'M');
    const uVPla = gl.getUniformLocation(PPLANTS, 'V');
    const uPPla = gl.getUniformLocation(PPLANTS, 'P');
    const uTimePla = gl.getUniformLocation(PPLANTS, 'g'); // Get location of time uniform for animation
    const IPla = gl.getUniformLocation(PPLANTS, 'h'); // Get location of max iterations uniform
    const uPlantPosPla = gl.getUniformLocation(PPLANTS, 'i');
    const uPlantSeedPla = gl.getUniformLocation(PPLANTS, 'j');

    const vboPlants = gl.createBuffer(), vaoPlants = gl.createVertexArray(); // Create vertex buffer and vertex array objects
    gl.bindVertexArray(vaoPlants); // Bind the vertex array object
    gl.bindBuffer(gl.ARRAY_BUFFER, vboPlants); // Bind the vertex buffer object
    // Vertex data for a quad (position and UV coordinates).
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1,2,0, 0,1,  1,2,0, 1,1,  1,0,0, 1,0,  -1,2,0, 0,1,  1,0,0, 1,0,  -1,0,0, 0,0]), gl.STATIC_DRAW); // Upload vertex data: 6 vertices forming 2 triangles for a quad, each with position (x,y,z) and UV (u,v)
    gl.enableVertexAttribArray(0); // Enable vertex attribute array at location 0 (position)
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 20, 0); // Set vertex attribute pointer for position: 3 floats, stride 20 bytes, offset 0
    gl.enableVertexAttribArray(1); // Enable vertex attribute array at location 1 (UV)
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 20, 12); // Set vertex attribute pointer for UV: 2 floats, stride 20 bytes, offset 12 bytes
    // -- /SOLUTION: Scene-Plant--
    // -- SOLUTION: Scene-Plant1--
    // -- /SOLUTION: Scene-Plant1--
    // -- /MODULE: Scene-Plant --
    
    // -- MODULE: Scene-VR (hand disc only) --
    // Reticle removed; single disc shader used for VR hand/grip indicator

    const vsDisc=`layout(location=0)in vec2 p;uniform mat4 M,V,P;out vec2 uv;void main(){uv=p*.5+.5;gl_Position=P*V*M*vec4(p.x,0.,p.y,1.);}`;
    const fsDisc=`in vec2 uv;uniform vec4 col;out vec4 o;void main(){float d=distance(uv,vec2(.5)),r=smoothstep(.5,.4,d)-smoothstep(.4,.3,d);o=vec4(col.rgb,col.a*r);if(o.a<.02)discard;}`;
    const PDisc = prog(vsDisc, fsDisc);
    const uMDisc = gl.getUniformLocation(PDisc, 'M'),
          uVDisc = gl.getUniformLocation(PDisc, 'V'),
          uPDisc = gl.getUniformLocation(PDisc, 'P'),
          uColDisc = gl.getUniformLocation(PDisc, 'col');

    const vboR = gl.createBuffer(), vaoR = gl.createVertexArray();
    gl.bindVertexArray(vaoR);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboR);
    // Quad for a 2D disc (two triangles), same layout used elsewhere
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1,-1,  1,-1,  1,1,  -1,-1,  1,1,  -1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);    

    // -- /MODULE: Scene-VR --

    // Beam for pointing ray.
    const fsBeam = `uniform vec4 col;out vec4 o;void main(){ o=col; }`;
    const PBeam = prog(vsMVP, fsBeam);
    const uMBeam = gl.getUniformLocation(PBeam, 'M'), uVBeam = gl.getUniformLocation(PBeam, 'V'), uPBeam = gl.getUniformLocation(PBeam, 'P'), uColBeam = gl.getUniformLocation(PBeam, 'col');
    const vboBeam = gl.createBuffer(), vaoBeam = gl.createVertexArray();
    gl.bindVertexArray(vaoBeam);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboBeam);
    // A simple quad scaled to form the beam
    gl.bufferData(gl.ARRAY_BUFFER, new F32([0,0,0, 1,0,0, 1,0,1, 0,0,0, 1,0,1, 0,0,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    // -- /MODULE: Scene-VR --
    // -- /FEATURE: Scene --
    
    // -- CORE: render --
    // --- Main Render Loop (Desktop) ---
    //let frameCount = 0;
    function loop(t) {
        // If an immersive XR session is active, stop the desktop loop chain.
        if (xr) return;  // prevents scheduling the next frame; XR loop takes over
        //frameCount++;
        
        // Calculate delta time
        const dt = ((t - last) / 1000) || 0;
        last = t;
        // Ensure rocks near the player are generated and present in obstacles for collision resolution
        // render only ever tenth frame to save CPU
        //if (frameCount % 10 === 0) {
            //updateRocks(u.x, u.z);
            for (let i = obstacles.length - 1; i >= 0; i--) {
            if (obstacles[i]._isRock) obstacles.splice(i, 1);
        }
        rocks.length = 0;
        //const c = 5; const r = 200.0;
        const minX = FLOOR((u.x - 300.)/5);
        const maxX = FLOOR((u.x + 300.)/5);
        const minZ = FLOOR((u.z - 300.)/5);
        const maxZ = FLOOR((u.z + 300.)/5);
        for(let gz=minZ; gz<=maxZ; gz++){
            for(let gx=minX; gx<=maxX; gx++){
                const h = rockHash(gx, gz, .0);
                if (h < .01){
                    const jx = rockHash(gx, gz, 1.) - .5;
                    const jz = rockHash(gx, gz, 2.) - .5;
                    const px = gx*5 + (jx * 5 * .6) + 5*.5;
                    const pz = gz*5 + (jz * 5 * .6) + 5*.5;
                    const dx = px - u.x, dz = pz - u.z;
                    if (dx*dx + dz*dz <= 300.*300.){
                        const seed = rockHash(gx, gz, -7.) * 1000.;
                        const scale = 4. + rockHash(gx, gz, 5.) * 2.; // 1.0 .. 6.0 meters
                        const rx = px, rz = pz, ry = scale * .45; // small y offset
                        const radius = scale * 1.2; // collision radius
                        const rock = { x: rx, y: ry, z: rz, r: radius, seed, scale };
                        rocks.push(rock);
                        // also add to obstacles so collision code picks it up
                        obstacles.push({ x: rx, y: ry, z: rz, r: radius, _isRock: true });
                    }
                }
            }
        }
        //}

        // Update user position
        const mv = getMove();
        step(dt, mv);
        // Update black cat AI & drops
        updateCat(dt);
        // MMO tick (send position)
        mmoTick(dt);
        // Trigger congrats overlay on catch
        if (cat.caught > lastCaughtShown) {
            lastCaughtShown = cat.caught;
            congratsTimer = 3.5;
        }
        //const moveMag = HYPOT(mv.x, mv.y);
        //updateAdaptiveMusic(moveMag, dt);
        updateAdaptiveMusic(HYPOT(mv.x, mv.y), dt);
        
        // Update camera matrices
        buildViewProj();
        // Update wind stereo each frame (after camera matrix updated)
        if(audioCtx) updateWind(t/1000, u.x, u.z, u.yaw);
        // --- Rendering ---
        gl.viewport(0, 0, C.width, C.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Render Sky
        gl.useProgram(PSKY);
        gl.bindVertexArray(vaoSky);
        gl.disable(gl.DEPTH_TEST);
        const Vinv = INV(V);
        gl.uniformMatrix4fv(uVinv, false, Vinv);
        gl.uniformMatrix4fv(uInvPV, false, invPV);
        //gl.uniform3fv(uSun, [0.1, 0.1, -0.9]);

        // Noise texture for clouds
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, noiseTex);
        gl.uniform1i(uNoiseSky, 1);
        gl.uniform1f(uTimeSky, t * .001);
        //gl.uniform1f(uCoverage, cloudCoverage);
        //gl.uniform1f(uSharpness, cloudSharpness);
        //gl.uniform1i(uShadowSamples, shadowSamples);
        //gl.uniform1f(uCloudHeightLoc, cloudHeight);
        //gl.uniform1f(uCloudScaleLoc, cloudScale);
        //gl.uniform1f(uCloudMotionSpeedLoc, cloudMotionSpeed);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        gl.enable(gl.DEPTH_TEST);

        // Render Grid
        gl.useProgram(PG);
        gl.bindVertexArray(vao);
        gl.uniformMatrix4fv(uM, false, M);
        gl.uniformMatrix4fv(uV, false, V);
        gl.uniformMatrix4fv(uP, false, P);
        //if (beastMode===true){
        //gl.enable(gl.CULL_FACE);
        //gl.cullFace(gl.FRONT)}
        //else {gl.disable(gl.CULL_FACE);};
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // --- Render Items & Obstacles (now works because drawSphere exists) ---
    for(const itm of items) if (itm.r>0) drawSphere(V,P,itm.x,itm.y,itm.z,itm.r,[.2,1.,.3]);
        //for(const o of obstacles) if(!o._isRock) drawSphere(V,P,o.x,o.y,o.z,o.r,[0.9,0.2,0.2]);
        for(const t of traps) drawSphere(V,P,t.x,t.y,t.z,t.r,[.8,.5,.1]);
        // Render Black Cat
        drawCat(V,P,cat.x,cat.y,cat.z,cat.yaw,cat.anim,.08,[.02,.02,.02]);

        // Render MMO peers as whitish cats (smoothed)
        if (peers && peers.size){
            const nowMs = performance.now();
            const targetT = nowMs - 120;
            peers.forEach((p,id)=>{
                if (id===myId) return;
                if ((nowMs - (p.last||0)) >= 15000) return; // stale peer
                const s = samplePeer(p, targetT) || p;
                drawCat(V,P,s.x,.6,s.z,(s.yaw||0)+PI,HYPOT(s.x, s.z)||1*dt*3.5,.1,PEER_COL);
            });
        }

        // Draw procedural rocks (flat-shaded, stylized)
        if (rocks.length) {
            gl.useProgram(PROCK);
            gl.bindVertexArray(rockVao);
            gl.uniformMatrix4fv(uR_V, false, V);
            gl.uniformMatrix4fv(uR_P, false, P);
            for (const rk of rocks) {
                gl.uniform3f(uR_Pos, rk.x, rk.y, rk.z);
                gl.uniform1f(uR_S, rk.scale);
                gl.uniform1f(uR_Seed, rk.seed);
                gl.drawArrays(gl.TRIANGLES, 0, rockVerts.length / 3);
            }
            //gl.enable(gl.DEPTH_TEST);
        }

        // Render Grass in multiple passes for density and LOD
        {
            const cy = COS(u.yaw), sy = SIN(u.yaw);
            const camRight = [cy, 0, -sy];
            const timeSec = t * .001;
            drawGrassPass(V, P, [u.x, u.z], camRight, timeSec, 1.1, 500, /*30.0,*/ 1.); // Cell size, Strands number, Radius(bad), Seed
            drawGrassPass(V, P, [u.x, u.z], camRight, timeSec, .4, 300, /*20.0,*/ 2.);
            drawGrassPass(V, P, [u.x, u.z], camRight, timeSec, .15, 200, /*10.0,*/ 3.);
        }

        // Render L-System Plants
        {
            gl.useProgram(PPLANTS);
            gl.bindVertexArray(vaoPlants);
            //gl.enable(gl.BLEND);
            //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            //gl.depthMask(false); // Render transparent objects without writing to depth buffer

            const camX = u.x;
            const camZ = u.z;
            //const plants = genPlants(camX, camZ);
            const plants = genPlants(camX, camZ, 55);

            // Only regenerate plants every 10 frames or if camera moved significantly
            //if (frameCount % 10 === 0) {// || HYPOT(camX - lastPlantCamX, camZ - lastPlantCamZ) > 2.) {
                //cachedPlants = genPlants(camX, camZ, 55);
                //lastPlantCamX = camX;
                //lastPlantCamZ = camZ;
            //}

            //for(const p of cachedPlants){
            for(const p of plants){
                const px = p.px, pz = p.pz, scale = p.scale;

                // Distance & LOD
                const dx = camX - px, dz = camZ - pz;
                const dist = HYPOT(dx, dz);

                //const NEAR_HIDE = 4.0;
                //const NEAR_FULL = 6.0;
                //const FAR_START = 18.0;
                //const FAR_HIDE  = 50.0;
                if(dist < 4. || dist > 55.) continue;

                //const MIN_ITER = 2, MAX_ITER = 14;
                const sstep = x => x*x*(3-2*x);
                let a = (dist - 4.)/(6.-4.); a = sstep(MIN(1, MAX(0,a)));
                let b = (55. - dist)/(55. - 18.); b = sstep(MIN(1, MAX(0,b)));
                let q = a * b;
                if(q < .05) continue;

                const key = p.gx + ',' + p.gz;
                //const target = 2 + q*(14 - 2);
                //const iterations = MAX(2, MIN(14, target)) | 0;
                const iterations = MAX(2, MIN(14, 2 + q*(14 - 2))) | 0;
                const plantSeed = plantHash(p.gx, p.gz, 4.);

                const angle = ATAN2(camX - px, camZ - pz);
                const MPlants = new DOMMatrix()
                    .translate(px, 0, pz)
                    .rotate(0, angle / D2R, 0) // fix: radians->degrees (was *D2R)
                    .scale(scale, scale, scale)
                    .toFloat32Array();

                gl.uniformMatrix4fv(uMPla, false, MPlants);
                gl.uniformMatrix4fv(uVPla, false, V);
                gl.uniformMatrix4fv(uPPla, false, P);
                gl.uniform1f(uTimePla, t * .001);
                gl.uniform1i(IPla, iterations);
                gl.uniform3f(uPlantPosPla, px, 0, pz);
                gl.uniform1f(uPlantSeedPla, plantSeed);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            //gl.depthMask(true);
            //gl.disable(gl.BLEND);
        }

        // Render Reticle if there's a ground hit
        //if (lastHit) {
        //    const T = translateScale(lastHit[0], 0.001, lastHit[2], 0.15, 1, 0.15);
        //    gl.useProgram(PR);
        //    gl.bindVertexArray(vaoR);
        //    gl.uniformMatrix4fv(uMR, false, T);
        //    gl.uniformMatrix4fv(uVR, false, V);
        //    gl.uniformMatrix4fv(uPR, false, P);
        //    gl.enable(gl.BLEND);
        //    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        //    gl.disable(gl.DEPTH_TEST);
        //    gl.drawArrays(gl.TRIANGLES, 0, 6);
        //    gl.enable(gl.DEPTH_TEST);
        //    gl.disable(gl.BLEND);
        //}


        // Render HUD
        const T = getHudTransform();
        const W = INV(V); // Get world-from-view matrix
        const WH = new DOMMatrix(W).multiply(new DOMMatrix(T)).toFloat32Array(); // Combine to get HUD's world matri
        HUD_WH_world = WH;
        hoverBtn = null;

        // Check for hover state if not in mouse-look mode
        if (I.look.id === null) {
            const r = rayFromScreen(I.pointer.x, I.pointer.y);
            const h = HUD_pick(WH, r, currentUI());
            if (h && h.button) hoverBtn = h.button;
        }

        updHUD('Desktop', lastHit, currentUI(), dt); // Redraw and upload HUD texture

        gl.useProgram(PH);
        gl.bindVertexArray(vaoH);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, hudTex);
        gl.uniform1i(uT, 0);
        gl.uniformMatrix4fv(uMH, false, WH);
        gl.uniformMatrix4fv(uVH, false, V);
        gl.uniformMatrix4fv(uPH, false, P);
        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);

        requestAnimationFrame(loop);
    }

    // Helper to update the HUD canvas content
    function updHUD(mode, hit, uiSet, dt) {
    if (congratsTimer > 0) congratsTimer = MAX(0, congratsTimer - dt);
        drawHUDCanvas(mode, hit, uiSet, dt);
    }

    // Helper to submit a sphere draw call
    function drawSphere(V,P,x,y,z,r,col){
        gl.useProgram(PS);
        gl.bindVertexArray(sphereVao);
        const Msp = translateScale(x,y,z,r,r,r);
        gl.uniformMatrix4fv(uS_M,false,Msp);
        gl.uniformMatrix4fv(uS_V,false,V);
        gl.uniformMatrix4fv(uS_P,false,P);
        gl.uniform3f(uS_Color,col[0],col[1],col[2]);
        gl.drawArrays(gl.TRIANGLES,0,sphereVerts.length/3);
    }

    // Helper to submit a grass draw call
    function drawGrassPass(Vmat, Pmat, camXZ, camRight, timeSec, cell, gridN, seed) {
        gl.useProgram(PGRASS);
        gl.bindVertexArray(vaoGrass);
        gl.uniformMatrix4fv(uVG, false, Vmat);
        gl.uniformMatrix4fv(uPG, false, Pmat);
        gl.uniform2f(uCamXZ, camXZ[0], camXZ[1]);
        gl.uniform3f(uCamRight, camRight[0], camRight[1], camRight[2]);
        gl.uniform1f(uTimeG, timeSec);
        gl.uniform1f(uCell, cell);
        gl.uniform1i(uGridN, gridN | 0);
        gl.uniform1f(uSeed, seed);
        // Bind noise texture once per pass
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, noiseTex);
        gl.uniform1i(uNoise, 0);
        //gl.enable(gl.DEPTH_TEST);
        gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 10, gridN * gridN);
    }

    // Computes the view and projection matrices for desktop mode
    function buildViewProj() {
      const cy = COS(u.yaw),
          sy = SIN(u.yaw);
      const cp = COS(u.pitch),
          sp = SIN(u.pitch);
      const eye = [u.x, u.y, u.z];
      const center = [u.x - sy * cp, u.y - sp, u.z - cy * cp];
        LOOKAT(V, eye, center, [0, 1, 0]);
        PERSP(P, 60, C.width / C.height, .1, 1000.);
        PV = MULTMAT4(M4(), P, V);
        invPV = INV(PV);
    }
    // -- /CORE: Render --

    // -- FEATURE: VR --
    // --- WebXR ---

    // Checks for WebXR support
    function initXR() {
        if (!('xr' in navigator)) {
            log('WebXR not available');
            return;
        }
        //navigator.xr.isSessionSupported('immersive-vr').then(s => log(s ? 'VR ready: Click Enter VR button' : 'VR error: reload and try again'));
        navigator.xr.isSessionSupported('immersive-vr').then(s => log(s ? 'VR ready: Click Enter VR' : 'VR error'));
    }
    // if vr not avalable we split screen in to stereo view

    // Toggles an immersive VR session
    async function toggleXRFromUI() {
        try {
            if (xr) {
                //cancelAnimationFrame(loop); // Stop desktop loop
                await xr.end(); // End the current session
                return;
            }
            // Request a new session
            xr = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'hand-tracking'] });
            uiEnterLabel = 'Exit VR';

            await gl.makeXRCompatible();
            xr.updateRenderState({ baseLayer: new XRWebGLLayer(xr, gl) });
            ref = await xr.requestReferenceSpace('local-floor');
            

            xr.addEventListener('end', () => {
                // Cleanup audio when the session ends
                audioCtx.close();
                //audioCtx = null;
                initAudio(); // Recreate audio context for desktop
                // If the canvas holds pointer lock, release it when exiting VR
                document.exitPointerLock();
                //cancelAnimationFrame(onXR); // Stop XR loop
                xr = null;
                uiEnterLabel = 'Enter VR';
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0,0,C.width,C.height);
                requestAnimationFrame(loop); // Resume desktop loop
            });

            last = 0;
            xr.requestAnimationFrame(onXR); // Start the XR render loop
            resetCatPosition();

        } catch (e) {
            log('XR failed: ' + e.message);
            //requestAnimationFrame(loop); // Resume desktop loop
        }
    }

    // -- Main Render Loop (WebXR) --
    
    function onXR(t, frame) {
        const s = frame.session;
        //if (s !== xr) return;
        s.requestAnimationFrame(onXR);
        //frameCount++;
        
        const dt = ((t - last) / 1000) || 0;
        last = t;
        
        const pose = frame.getViewerPose(ref);
        if (!pose) return;
        
        // NEW: update wind stereo each frame (after camera matrix updated)
        if(audioCtx) updateWind(t/1000, u.x, u.z, u.yaw);
        
        // Ensure rocks near the player are generated and present in obstacles for collision resolution
        // render only ever tenth frame to save CPU
        //if (frameCount % 10 === 0) {
            //updateRocks(u.x, u.z);
            for (let i = obstacles.length - 1; i >= 0; i--) {
                if (obstacles[i]._isRock) obstacles.splice(i, 1);
            }
            rocks.length = 0;
            //const c = 5; const r = 400.0;
            const minX = FLOOR((u.x - 500.)/5);
            const maxX = FLOOR((u.x + 500.)/5);
            const minZ = FLOOR((u.z - 500.)/5);
            const maxZ = FLOOR((u.z + 500.)/5);
            for(let gz=minZ; gz<=maxZ; gz++){
                for(let gx=minX; gx<=maxX; gx++){
                    const h = rockHash(gx, gz, .0);
                    if (h < .01){
                        const jx = rockHash(gx, gz, 1.) - .5;
                        const jz = rockHash(gx, gz, 2.) - .5;
                        const px = gx*5 + (jx * 5 * .6) + 5*.5;
                        const pz = gz*5 + (jz * 5 * .6) + 5*.5;
                        const dx = px - u.x, dz = pz - u.z;
                        if (dx*dx + dz*dz <= 500.*500.){
                            const seed = rockHash(gx, gz, -7.) * 1000.;
                            const scale = 4. + rockHash(gx, gz, 5.) * 2.; // 1.0 .. 6.0 meters
                            const rx = px, rz = pz, ry = scale * .45; // small y offset
                            const radius = scale * 1.2; // collision radius
                            const rock = { x: rx, y: ry, z: rz, r: radius, seed, scale };
                            rocks.push(rock);
                            // also add to obstacles so collision code picks it up
                            obstacles.push({ x: rx, y: ry, z: rz, r: radius, _isRock: true });
                        }
                    }
                }
            }
        //}
        
        // Apply movement based on controller input
        const mv = getMove(s);
        step(dt, mv);
        // Update black cat AI & drops
        updateCat(dt);
        // MMO tick (send position)
        mmoTick(dt);
        // Trigger congrats overlay on catch
        if (cat.caught > lastCaughtShown) {
            lastCaughtShown = cat.caught;
            congratsTimer = 5.5;
        }
        //const moveMag = HYPOT(mv.x, mv.y);
        //updateAdaptiveMusic(moveMag, dt);
        updateAdaptiveMusic(HYPOT(mv.x, mv.y), dt);
        
        // Create an offset reference space to account for user-controlled movement
        const half = -u.yaw * .5;
        const rot = new XRRigidTransform({x:0,y:0,z:0}, { x:0,y:SIN(half), z:0, w:COS(half) });
        const rRef = ref.getOffsetReferenceSpace(rot);
        off = rRef.getOffsetReferenceSpace(new XRRigidTransform({x:-u.x,y:0,z:-u.z}));
        const rel = frame.getViewerPose(off);
        if (!rel) return;// no viewer pose, skip frame

        // -- VR Input and Interaction --
        //for (const src of (s.inputSources && Symbol.iterator in Object(s.inputSources) ? s.inputSources : [])) {
        for (const src of s.inputSources || []) {
            const gp = src.gamepad;
            if (!gp || !gp.buttons || !gp.buttons.length) continue;

            const now = !!gp.buttons[0].pressed;
            const prev = pressedMap.get(src) || false;

            // On button press (edge detection)
            if (now && !prev) {
                //playClickSound();
                const r = rayFrom('VR', frame, src);
                const viewer = frame.getViewerPose(off);
                if (viewer) {
                    const T = getHudTransform();
                    // World-from-viewer in offset space (consistent for both eyes)
                    const WH = new DOMMatrix(rel.transform.matrix).multiply(new DOMMatrix(T)).toFloat32Array();
                    //HUD_WH_world = WH;
                    const h = HUD_pick(WH, r, currentUI());

                    if (h && h.button) {
                        h.button.onClick();
                    } //else {
                    //    const g = rayHitGround(r);
                    //    if (g) { lastHit = g; log('ground ' + g.map(v => v.toFixed(2)).join(',')); }
                    //}
                }
            }
            pressedMap.set(src, now);
        }

        // -- VR Rendering --

        gl.bindFramebuffer(gl.FRAMEBUFFER, s.renderState.baseLayer.framebuffer);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        //gl.enable(gl.DEPTH_TEST);

        // Render the scene for each eye
        for (const v of rel.views) {
            const vp = s.renderState.baseLayer.getViewport(v);
            gl.viewport(vp.x, vp.y, vp.width, vp.height);

            // Per-eye matrices
            const Veye = v.transform.inverse.matrix;
            const VinvEye = INV(Veye);
            const PVeye = MULTMAT4(M4(), v.projectionMatrix, Veye);
            const invPVEye = INV(PVeye);

            // Render Sky
            gl.useProgram(PSKY);
            gl.bindVertexArray(vaoSky);
            gl.disable(gl.DEPTH_TEST);
            gl.uniformMatrix4fv(uVinv, false, VinvEye);
            gl.uniformMatrix4fv(uInvPV, false, invPVEye);
            //gl.uniform3fv(uSun, [0.1, 0.1, -0.9]);

            // Sky uniforms per-eye (same tuning rules apply)
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, noiseTex);
            gl.uniform1i(uNoiseSky, 1);
            gl.uniform1f(uTimeSky, t * .001);
            //gl.uniform1f(uCoverage, cloudCoverage);
            //gl.uniform1f(uSharpness, cloudSharpness);
            //gl.uniform1i(uShadowSamples, shadowSamples);
            //gl.uniform1f(uCloudHeightLoc, cloudHeight);
            //gl.uniform1f(uCloudScaleLoc, cloudScale);       // adjust for global cloud size
            //gl.uniform1f(uCloudMotionSpeedLoc, cloudMotionSpeed);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            gl.enable(gl.DEPTH_TEST);

            // Render Grid
            gl.useProgram(PG);
            gl.bindVertexArray(vao);
            gl.uniformMatrix4fv(uM, false, M);
            gl.uniformMatrix4fv(uV, false, v.transform.inverse.matrix);
            gl.uniformMatrix4fv(uP, false, v.projectionMatrix);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // --- NEW: Render Items & Obstacles (now works because drawSphere exists) ---
            for(const itm of items) if (itm.r>0) drawSphere(v.transform.inverse.matrix,v.projectionMatrix,itm.x,itm.y,itm.z,itm.r,[.2,1.,.3]);
            //for(const o of obstacles)  if(!o._isRock) drawSphere(v.transform.inverse.matrix,v.projectionMatrix,o.x,o.y,o.z,o.r,[0.9,0.2,0.2]);
            for(const t of traps) drawSphere(v.transform.inverse.matrix,v.projectionMatrix,t.x,t.y,t.z,t.r,[.8,.5,.1]);
            // Render Black Cat
            drawCat(v.transform.inverse.matrix,v.projectionMatrix,cat.x,cat.y,cat.z,cat.yaw,cat.anim,.08,[.02,.02,.02]);

            // Render MMO peers (VR eye, smoothed)
            if (peers && peers.size){
                const nowMs = performance.now();
                const targetT = nowMs - 120;
                peers.forEach((p,id)=>{
                    if (id===myId) return;
                    if ((nowMs - (p.last||0)) >= 15000) return;
                    const s = samplePeer(p, targetT) || p;
                    drawCat(v.transform.inverse.matrix, v.projectionMatrix, s.x, .6, s.z,(s.yaw||0)+PI,HYPOT(s.x, s.z)||1*dt*3.5,.1, PEER_COL);
                });
            }

            // Draw procedural rocks (flat-shaded, stylized)
            if (rocks.length) {
                gl.useProgram(PROCK);
                gl.bindVertexArray(rockVao);
                gl.uniformMatrix4fv(uR_V, false, v.transform.inverse.matrix);
                gl.uniformMatrix4fv(uR_P, false, v.projectionMatrix);
                for (const rk of rocks) {
                    gl.uniform3f(uR_Pos, rk.x, rk.y, rk.z);
                    gl.uniform1f(uR_S, rk.scale);
                    gl.uniform1f(uR_Seed, rk.seed);
                    gl.drawArrays(gl.TRIANGLES, 0, rockVerts.length / 3);
                }
                //gl.enable(gl.DEPTH_TEST);
            }


            // Render Grass
            {
                const worldFromView = v.transform.matrix;
                const camXZ = [worldFromView[12], worldFromView[14]];
                const camRight = [worldFromView[0], worldFromView[1], worldFromView[2]];
                const timeSec = t * .001;
                drawGrassPass(v.transform.inverse.matrix, v.projectionMatrix, camXZ, camRight, timeSec, 1.1, 2000, /*30.0,*/ 1); 
                drawGrassPass(v.transform.inverse.matrix, v.projectionMatrix, camXZ, camRight, timeSec, .3, 1000, /*20.0,*/ 2);
                drawGrassPass(v.transform.inverse.matrix, v.projectionMatrix, camXZ, camRight, timeSec, .15, 500, /*10.0,*/ 3);
            }

            // Render L-System Plants
            {
                gl.useProgram(PPLANTS);
                gl.bindVertexArray(vaoPlants);
                //gl.enable(gl.BLEND);
                //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                //gl.depthMask(false); // Render transparent objects without writing to depth buffer

                const worldFromView = v.transform.matrix;
                const camX = worldFromView[12];
                const camZ = worldFromView[14];
                //const plants = genPlants(camX, camZ);
                const plants = genPlants(camX, camZ, 120);
                
                // Only regenerate plants every 10 frames or if camera moved significantly
                ///if (frameCount % 10 === 0) {// || HYPOT(camX - lastPlantCamX, camZ - lastPlantCamZ) > 5.) {
                    //cachedPlants = genPlants(camX, camZ,120);
                    //lastPlantCamX = camX;
                    //lastPlantCamZ = camZ;
                //}

            //if (frameCount % 10 === 0) {
            //for(const p of cachedPlants){
            for(const p of plants){
                const px = p.px, pz = p.pz, scale = p.scale;

                // Distance & LOD
                const dx = camX - px, dz = camZ - pz;
                const dist = HYPOT(dx, dz);

                //const NEAR_HIDE = 4.0;
                //const NEAR_FULL = 6.0;
                //const FAR_START = 18.0;
                //const FAR_HIDE  = 50.0;
                if(dist < 4. || dist > 120.) continue;

                //const MIN_ITER = 2, MAX_ITER = 16;
                const sstep = x => x*x*(3-2*x);
                let a = (dist - 4.)/(6.-4.); a = sstep(MIN(1, MAX(0,a)));
                let b = (120. - dist)/(120. - 18.); b = sstep(MIN(1, MAX(0,b)));
                let q = a * b;
                if(q < .05) continue;

                const key = p.gx + ',' + p.gz;
                //const target = 2 + q*(16 - 2);
                //const iterations = MAX(2, MIN(16, target)) | 0;
                const iterations = MAX(2, MIN(16, 2 + q*(14 - 2))) | 0;
                const plantSeed = plantHash(p.gx, p.gz, 4.);

                const angle = ATAN2(camX - px, camZ - pz);
                const MPlants = new DOMMatrix()
                    .translate(px, 0, pz)
                    .rotate(0, angle / D2R, 0)
                    .scale(scale, scale, scale)
                    .toFloat32Array();

                gl.uniformMatrix4fv(uMPla, false, MPlants);
                gl.uniformMatrix4fv(uVPla, false, v.transform.inverse.matrix);
                gl.uniformMatrix4fv(uPPla, false, v.projectionMatrix);
                gl.uniform1f(uTimePla, t * .001);
                gl.uniform1i(IPla, iterations);
                gl.uniform3f(uPlantPosPla, px, 0, pz);
                gl.uniform1f(uPlantSeedPla, plantSeed);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            //gl.depthMask(true);
            //gl.disable(gl.BLEND);
            }

            // Render Reticle
            //if (lastHit) {
            //    const Tm = translateScale(lastHit[0], 0.001, lastHit[2], 0.15, 1, 0.15);
            //    gl.useProgram(PR);
            //    gl.bindVertexArray(vaoR);
            //    gl.uniformMatrix4fv(uMR, false, Tm);
            //    gl.uniformMatrix4fv(uVR, false, v.transform.inverse.matrix);
            //    gl.uniformMatrix4fv(uPR, false, v.projectionMatrix);
            //    gl.enable(gl.BLEND); 
            //    gl.blendFunc(gl.SRC_ALPHA, 
            //    gl.ONE_MINUS_SRC_ALPHA);
            //    gl.disable(gl.DEPTH_TEST); 
            //    gl.drawArrays(gl.TRIANGLES, 0, 6);
            //    gl.enable(gl.DEPTH_TEST); 
            //    gl.disable(gl.BLEND);
            //}
            
            // Render HUD
            const T = getHudTransform();
            // World-from-viewer in offset space (consistent for both eyes)
            const WH = new DOMMatrix(rel.transform.matrix).multiply(new DOMMatrix(T)).toFloat32Array(); // Hud snaped to eyes, bad
            HUD_WH_world = WH;
            hoverBtn = null;
            for (const src of s.inputSources || []) {
                const r = controllerRay(frame, src);
                const h = HUD_pick(WH, r, currentUI());
                if (h && h.button) { hoverBtn = h.button; break; }
            }
            updHUD('VR', lastHit, currentUI(), dt);
            gl.useProgram(PH);
            gl.bindVertexArray(vaoH);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, hudTex);
            gl.uniform1i(uT, 0);
            gl.uniformMatrix4fv(uMH, false, WH);
            gl.uniformMatrix4fv(uVH, false, v.transform.inverse.matrix);
            gl.uniformMatrix4fv(uPH, false, v.projectionMatrix);
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);

            // Render Controller Indicators and Rays
            for (const src of s.inputSources || []) {
                const col = [1, 1, .5]

                // Hand grip indicator
                const grip = src.gripSpace ? frame.getPose(src.gripSpace, off) : null;
                if (grip) {
                    const Mhand = new DOMMatrix(grip.transform.matrix).multiply(new DOMMatrix([.06,0,0,0, 0,.06,0,0, 0,0,.06,0, 0,0,0,1])).toFloat32Array();
                    gl.useProgram(PDisc);
                    gl.bindVertexArray(vaoR);

                    gl.uniformMatrix4fv(uMDisc, false, Mhand);
                    gl.uniformMatrix4fv(uVDisc, false, v.transform.inverse.matrix); 
                    gl.uniformMatrix4fv(uPDisc, false, v.projectionMatrix);
                    gl.uniform4f(uColDisc, col[0], col[1], col[2], .95);
                    gl.disable(gl.DEPTH_TEST); 
                    gl.enable(gl.BLEND); 
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND); 
                    gl.enable(gl.DEPTH_TEST);
                }

                // Laser beam
                const targ = src.targetRaySpace ? frame.getPose(src.targetRaySpace, off) : null;
                if (targ) {
                    const r = controllerRay(frame, src);
                    const triggerVal = (src.gamepad && src.gamepad.buttons && src.gamepad.buttons[0]) ? (src.gamepad.buttons[0].value || 0) : 0;
                    const w = .004 + .01 * triggerVal; // Beam gets thicker when trigger is pressed
                    let len = 3.;
                    //const tGround = (0 - r.o[1]) / r.d[1];
                    //if (tGround > 0) len = MIN(len, MIN(5.0, tGround));
                    const h = HUD_pick(WH, r, currentUI());
                    if (h) len = MIN(len, h.t); // Shorten beam if it hits the HUD
                    
                    const S = new DOMMatrix([w,0,0,0, 0,w,0,0, 0,0,-len,0, 0,0,0,1]);
                    const Mbeam = new DOMMatrix(targ.transform.matrix).multiply(S).toFloat32Array();
                    gl.useProgram(PBeam); 
                    gl.bindVertexArray(vaoBeam);
                    gl.uniformMatrix4fv(uMBeam, false, Mbeam); 
                    gl.uniformMatrix4fv(uVBeam, false, v.transform.inverse.matrix); 
                    gl.uniformMatrix4fv(uPBeam, false, v.projectionMatrix);
                    gl.uniform4f(uColBeam, col[0], col[1], col[2], .8);
                    gl.disable(gl.DEPTH_TEST); 
                    gl.enable(gl.BLEND); 
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND); 
                    gl.enable(gl.DEPTH_TEST);

                    // Ground hit indicator for the controller ray
                    //const g = rayHitGround(r);
                    //if (g) {
                    //    const Mhit = translateScale(g[0], 0.001, g[2], 0.09, 1, 0.09);
                    //    gl.useProgram(PDisc); 
                    //    gl.bindVertexArray(vaoR);
                    //    gl.uniformMatrix4fv(uMDisc, false, Mhit); 
                    //    gl.uniformMatrix4fv(uVDisc, false, v.transform.inverse.matrix); 
                    //    gl.uniformMatrix4fv(uPDisc, false, v.projectionMatrix);
                    //    gl.uniform4f(uColDisc, 1.0, 0.95, 0.3, 0.95);
                    //    gl.disable(gl.DEPTH_TEST); 
                    //    gl.enable(gl.BLEND); 
                    //    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    //    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    //    gl.disable(gl.BLEND); 
                    //    gl.enable(gl.DEPTH_TEST);
                    //}
                }
            }
        }
    }

    // -- /FEATURE: VR --
    
    // -- FEATURE: CORE --
    // --- Application Entry Point ---
    (function main() {
        initXR();
        requestAnimationFrame(loop);
        log(`Catch the Black Cat 13 times`);
        //log(`Catch the black cat!`);
        log('Close HUD: X/H/Esc');
        //log('Touch-drag to Look around');
        //if (!isMobile) log('Move: WASD, Rotate: Q & E');
        log('Move: WASD, Rotate: Q & E');
        //if (isMobile) log('Move: left joy, Rotate: right joy');
        log('Move: left, Rotate: right');
        //log('Move: '+(isMobile ? 'left joy' : 'WASD')+', Rotate: '+(isMobile ? 'right joy' : 'Q & E'));
    })();
    
    // -- /FEATURE: CORE --
    </script>
</body>
</html>