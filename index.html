<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>'Wild Cats' 13K Game 2025</title>
    <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="55%" x="50%" dominant-baseline="middle" text-anchor="middle" font-size="80">üêà‚Äç‚¨õ</text></svg>'>
    <style>
        /* Basic styles to make the canvas and joysticks fill the screen */
        html, body {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }

        /* Styling for the virtual joysticks */
        .joystick {
            position: fixed;
            width: 112px;
            height: 112px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.25);
            z-index: 10;
            display: none; /* Hidden by default, shown for touch devices */
        }

        /* The movable part of the joystick */
        .joystick-handle {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* The handle itself doesn't capture clicks */
        }

        /* Positioning for left and right joysticks */
        #leftJoy { bottom: 36px; left: 36px; }
        #rightJoy { bottom: 36px; right: 36px; }

        /* Media query to show joysticks only on touch-capable (coarse pointer) devices */
        @media (pointer:coarse) {
            .joystick { display: block; }
        }
    </style>
</head>
<body>
    <!-- The main canvas for WebGL rendering -->
    <!-- <canvas id="C"></canvas> -->
    <canvas id="canvas"></canvas>

    <!-- HTML elements for the virtual joysticks -->
    <div id="leftJoy" class="joystick"><div class="joystick-handle"></div></div>
    <div id="rightJoy" class="joystick"><div class="joystick-handle"></div></div>

    <script>
    // -- FEATURE: Core --
    // Expose Math functions to global scope
    Object.getOwnPropertyNames(Math).forEach(n => window[n.toUpperCase()] = Math[n]);
    // --- Math Library ---
    const D2R = 0.0174532925 // or PI / 180;
    const F32 = Float32Array;
    const M4 = (v) => new F32(v || [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
    const V3 = (v) => new F32(v || 3);
    const T_V3_A = V3(), T_V3_B = V3(), T_V3_C = V3(); // Reusable temporary V3s
    const T_V4_A = V3(4), T_V4_B = V3(4); // Reusable temporary V4s
    const T_V3_RAY_O = V3(), T_V3_RAY_D = V3(); // For raycasting results (Origin, Direction)
    const SUB=(t,n,r)=>(t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t);
    const DOT=(t,n)=>t[0]*n[0]+t[1]*n[1]+t[2]*n[2];
    const CROSS=(t,n,r)=>(t[0]=n[1]*r[2]-n[2]*r[1],t[1]=n[2]*r[0]-n[0]*r[2],t[2]=n[0]*r[1]-n[1]*r[0],t);
    const LEN=(t)=>HYPOT(t[0],t[1],t[2]);
    const NORM=(t,n)=>{var r=LEN(n);return r>0&&(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r),t};
    const MULTMAT4 = (o, a, b) => (o.set((new DOMMatrix(a)).multiply(new DOMMatrix(b)).toFloat32Array()), o);
    const INV = (m) => (new DOMMatrix(m)).inverse().toFloat32Array();
    const PERSP = (o, f, a, n, fa) => { const t = 1 / TAN(f * D2R / 2); o.set([t/a,0,0,0, 0,t,0,0, 0,0,(fa+n)/(n-fa),-1, 0,0,(2*fa*n)/(n-fa),0]); return o; };
    const LOOKAT = (o, e, c, u) => { SUB(T_V3_A,e,c); NORM(T_V3_A,T_V3_A); CROSS(T_V3_B,u,T_V3_A); NORM(T_V3_B,T_V3_B); CROSS(T_V3_C,T_V3_A,T_V3_B); o.set([T_V3_B[0],T_V3_C[0],T_V3_A[0],0, T_V3_B[1],T_V3_C[1],T_V3_A[1],0, T_V3_B[2],T_V3_C[2],T_V3_A[2],0, -DOT(T_V3_B,e),-DOT(T_V3_C,e),-DOT(T_V3_A,e),1]); return o; };
    // --- World Matrices ---
    const M = M4(), V = M4(), P = M4(); // Model, View, Projection
    let PV = M4(), invPV = M4(); // Combined and inverse matrices for picking

    // Multiplies a 3D point (w=1) by a 4x4 matrix
    function mulPoint(m, p) { const x=p[0],y=p[1],z=p[2],w=1; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    // Multiplies a 3D direction (w=0) by a 4x4 matrix
    function mulDir(m, d) { const x=d[0],y=d[1],z=d[2],w=0; return [m[0]*x+m[4]*y+m[8]*z+m[12]*w, m[1]*x+m[5]*y+m[9]*z+m[13]*w, m[2]*x+m[6]*y+m[10]*z+m[14]*w]; }

    //function mul4(m, v) { return [m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3], m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3], m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3], m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3]]; }
    const mul4 = (out, m, v) => {
        const v0=v[0], v1=v[1], v2=v[2], v3=v[3];
        out[0] = m[0]*v0 + m[4]*v1 + m[8]*v2 + m[12]*v3;
        out[1] = m[1]*v0 + m[5]*v1 + m[9]*v2 + m[13]*v3;
        out[2] = m[2]*v0 + m[6]*v1 + m[10]*v2 + m[14]*v3;
        out[3] = m[3]*v0 + m[7]*v1 + m[11]*v2 + m[15]*v3;
        return out;
    };
    


    // Creates a translation and scale matrix
    function translateScale(x,y,z,sx,sy,sz) { return new F32([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, x,y,z,1]); }

    // const D = document
    // const C = D.getElementById('canvas');
    const canvas = document.getElementById('canvas');
    
   // State variables for the user/camera, rendering loop, and WebGL/WebXR contexts
    let user = { x: 0, y: 1.6, z: 2, yaw: 0, pitch: 0 }; // User position and orientation
    let last = 0; // Timestamp of the last frame for calculating delta time
    let gl, xr = null, ref = null, off = null; // WebGL and WebXR objects

    gl = canvas.getContext('webgl2', { antialias: true, xrCompatible: true });
    if (!gl) { alert('WebGL2 is required for this application.'); }

    // Resize the canvas to fill the window, accounting for device pixel ratio
    function resize() {
        const w = innerWidth, h = innerHeight, dpr = devicePixelRatio || 1;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
    }
    addEventListener('resize', resize);
    resize(); // Initial resize

    // Helper function to compile and link a shader program
    function prog(vs, fs) {
        const p = gl.createProgram();
        const v = gl.createShader(gl.VERTEX_SHADER);
        const f = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(v, vs); gl.compileShader(v);
        if (!gl.getShaderParameter(v, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(v);
        gl.shaderSource(f, fs); gl.compileShader(f);
        if (!gl.getShaderParameter(f, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(f);
        gl.attachShader(p, v); gl.attachShader(p, f); gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
        return p;
    }
    // -- /FEATURE: Core --

    // -- FEATURE: Input --
    // -- MODULE: Input-Core --
    // --- Unified Input Handling ---
    // Check if the primary input is a coarse pointer (like a finger), indicating a mobile/touch device
    const isMobile = matchMedia('(pointer:coarse)').matches;
    // Unified input state object for keyboard, joysticks, pointer-look, and pointer coordinates
    const input = {
        keys: {},
        joy: { left: { x: 0, y: 0, id: null }, right: { x: 0, y: 0, id: null } }, // 
        look: { id: null, x: 0, y: 0 },
        pointer: { x: 0, y: 0 }
    };
    const DZ = 0.1;    // Deadzone for joystick/gamepad axes to prevent drift
    // A map to track the previous pressed state of VR controller buttons for edge detection (press/release)
    const pressedMap = new Map();

    // State for the raycast
    let lastHit = null;
    // -- /MODULE: Input-Core --
    
    // -- MODULE: Input-KeyPoint --
    // Keyboard event listeners for movement and HUD toggle
    document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        input.keys[k] = true;
        if (k === 'h' || k === 'escape') {playClickSound(); hudVisible = !hudVisible;} // 'H' and escape key toggles HUD visibility
        if (k === 'f') {playClickSound(); beastMode = !beastMode;} // 'F' key toggles beastMode
    });
    document.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
    
    // Pointer event listeners on the canvas for mouse-look and interaction
    canvas.addEventListener('pointerdown', e => {
        initAudio(); // NEW: Initialize audio on first user interaction
        // Start mouse-look on left-click
        if (e.button === 0 && input.look.id === null) {
            input.look.id = e.pointerId;
            input.look.x = e.clientX;
            input.look.y = e.clientY;
            canvas.setPointerCapture(e.pointerId); // Lock the pointer to the canvas
        }
        // Always update pointer position for picking
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
    });
    
    canvas.addEventListener('pointermove', e => {
        // Update pointer position for hover effects
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
        
        // If we are in mouse-look mode, update camera orientation
        if (e.pointerId === input.look.id) {
            const dx = e.clientX - input.look.x;
            const dy = e.clientY - input.look.y;
            input.look.x = e.clientX;
            input.look.y = e.clientY;
            user.yaw += dx * 0.002;
            user.pitch = MAX(-PI / 2+0.001, MIN(PI / 2-0.001, user.pitch - dy * 0.002));
        }
    });
    
    canvas.addEventListener('pointerup', e => {
        // Stop mouse-look mode.
        if (e.pointerId === input.look.id) {
            input.look.id = null;
        }
        // Update pointer position and trigger an interaction check
        input.pointer.x = e.clientX;
        input.pointer.y = e.clientY;
        interactDesktopAt(e.clientX, e.clientY);
    });
    
    canvas.addEventListener('pointercancel', e => {
        if (e.pointerId === input.look.id) {
            input.look.id = null;
        }
    });
    // -- /MODULE: Input-KeyPoint --
    
    // -- MODULE: Input-Joystick --
    // --- Virtual Joysticks for Touch Devices ---
    function initJoysticks() {
        const joys = [
            { side: 'left', el: document.getElementById('leftJoy') },
            { side: 'right', el: document.getElementById('rightJoy') }
        ];
        const handleSel = s => document.querySelector('#' + s + 'Joy .joystick-handle');

        for (const j of joys) {
            const handle = handleSel(j.side);
            j.el.addEventListener('pointerdown', e => { initAudio(); j.id = e.pointerId; j.el.setPointerCapture(e.pointerId); updateJoy(j, e, handle); });
            j.el.addEventListener('pointermove', e => { if (e.pointerId === j.id) updateJoy(j, e, handle); });
            j.el.addEventListener('pointerup', e => { if (e.pointerId === j.id) { resetJoy(j, handle); } });
            j.el.addEventListener('pointercancel', e => { if (e.pointerId === j.id) { resetJoy(j, handle); } });
        }

        function updateJoy(j, e, handle) {
            const r = j.el.getBoundingClientRect();
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const R = r.width / 2 - 6; // Max radius for handle movement
            const dx = e.clientX - cx;
            const dy = e.clientY - cy;
            const L = MIN(HYPOT(dx, dy), R);
            const a = ATAN2(dy, dx);

            // Normalize joystick output from -1 to 1
            const x = L > DZ * 30 ? (L / R) * COS(a) : 0;
            const y = L > DZ * 30 ? (L / R) * SIN(a) : 0;

            input.joy[j.side].x = x;
            input.joy[j.side].y = y;

            // Update handle's visual position
            handle.style.transform = `translate(calc(-50% + ${x * R}px), calc(-50% + ${y * R}px))`;
        }

        function resetJoy(j, handle) {
            input.joy[j.side].x = 0;
            input.joy[j.side].y = 0;
            handle.style.transform = 'translate(-50%, -50%)';
            j.id = null;
        }
    }
    initJoysticks();
    // -- /MODULE:Input-Joystick --
    // -- MODULE: Input-Ray --
    // --- Raycasting and Picking ---
    // Checks if a world-space ray intersects with a button on the HUD
    // -- SOLUTION: Input-Ray-Screen --
    // Creates a world-space ray from screen coordinates (for desktop mouse picking)
    function rayFromScreen(px, py) {
        const r = canvas.getBoundingClientRect();
        const x = ((px - r.left) / r.width) * 2 - 1;
        const y = 1 - ((py - r.top) / r.height) * 2;
        //const near = [x, y, -1, 1], far = [x, y, 1, 1];
        // Use T_V4_A for the 'near' and T_V4_B for the 'far' vector4s
        T_V4_A[0] = x; T_V4_A[1] = y; T_V4_A[2] = -1; T_V4_A[3] = 1;
        T_V4_B[0] = x; T_V4_B[1] = y; T_V4_B[2] = 1;  T_V4_B[3] = 1;

        // Unproject near and far points from clip space to world space
        //const n4 = mul4(invPV, near),
        //      f4 = mul4(invPV, far);
        //const n = [n4[0] / n4[3], n4[1] / n4[3], n4[2] / n4[3]];
        //const f = [f4[0] / f4[3], f4[1] / f4[3], f4[2] / f4[3]];
        
        // Unproject, writing the results back into our temporary V4s
        mul4(T_V4_A, invPV, T_V4_A);
        mul4(T_V4_B, invPV, T_V4_B);

        // Convert to 3D points, writing to our dedicated ray vectors
        T_V3_RAY_O[0] = T_V4_A[0] / T_V4_A[3]; T_V3_RAY_O[1] = T_V4_A[1] / T_V4_A[3]; T_V3_RAY_O[2] = T_V4_A[2] / T_V4_A[3]; // This is 'n' (the origin)
        T_V3_A[0]    = T_V4_B[0] / T_V4_B[3]; T_V3_A[1]    = T_V4_B[1] / T_V4_B[3]; T_V3_A[2]    = T_V4_B[2] / T_V4_B[3]; // This is 'f' (the far point)


        // Create a normalized direction vector.
        //const d = [f[0] - n[0], f[1] - n[1], f[2] - n[2]];
        //const il = 1 / HYPOT(d[0], d[1], d[2]);
        //return { o: n, d: [d[0] * il, d[1] * il, d[2] * il] };

        
        // Calculate the direction vector into T_V3_RAY_D
        SUB(T_V3_RAY_D, T_V3_A, T_V3_RAY_O);
        NORM(T_V3_RAY_D, T_V3_RAY_D);
            
        return { o: T_V3_RAY_O, d: T_V3_RAY_D };


    }
    // Handles a click/tap interaction in desktop mode
    function interactDesktopAt(px, py) {
        const ui = currentUI();
        const r = rayFromScreen(px, py);
        if (!r) return;
        const WH = HUD_WH_world;
        const h = HUD_pick(WH, r, ui);

        if (h && h.button) {
            h.button.onClick(); // A button was clicked
            return;
        }

        // If no button was clicked, check for a hit on the ground
        const g = rayHitGround(r);
        if (g) {
            lastHit = g;
            log('ground ' + g.map(v => v.toFixed(2)).join(','));
        }
    }

    // Calculates the intersection point of a ray with the ground plane (Y=0)
    function rayHitGround(ray) {
        if (!ray || ray.d[1] >= 0) return null; // Ray is parallel to or going away from the ground
        const t = (0 - ray.o[1]) / ray.d[1];
        if (t > 0) {
            return [ray.o[0] + ray.d[0] * t, 0.001, ray.o[2] + ray.d[2] * t];
        }
        return null;
    }

    //const d = [-sy * cp, -sp, -cy * cp];
    //const o = [user.x, user.y, user.z];
    //return { o, d };
    //T_V3_RAY_D[0] = -sy * cp; T_V3_RAY_D[1] = -sp; T_V3_RAY_D[2] = -cy * cp;
    //T_V3_RAY_O[0] = user.x; T_V3_RAY_O[1] = user.y; T_V3_RAY_O[2] = user.z;
    //return { o: T_V3_RAY_O, d: T_V3_RAY_D };

    // -- /MODULE: Input-Ray --
    // -- /FEATURE: Input --

    // -- FEATURE: Gameplay --
    let beastMode = false; // toggle beast mode
    // -- MODULE: Gameplay-Movement --
    // --- Movement Logic ---
    // Movement and input constants
    const MOVES = 3;    // Movement speed in meters per second
    const TURNS = 2;    // Turning speed in radians per second

    // Consolidates input from keyboard, joysticks, and VR controllers into a single movement vector
    function getMove(session) {
        let vx = 0, vy = 0, vt = 0;
        // -- SOLUTION: Gameplay-Movement-Keyboard --
        // Keyboard input (WASD for move, QE for turn)
        const kx = (+!!input.keys.d) - (+!!input.keys.a);
        const ky = (+!!input.keys.w) - (+!!input.keys.s);
        const kt = (+!!input.keys.q) - (+!!input.keys.e);
        // -- /SOLUTION: Gameplay-Movement-Keyboard --
    
        // -- SOLUTION: Gameplay-Movement-Joystick --
        // Virtual joystick input
        const jx = input.joy.left.x;
        const jy = -input.joy.left.y;
        const jt = -input.joy.right.x;
        // -- /SOLUTION: Gameplay-Movement-Joystick --

        // -- SOLUTION: Gameplay-Movement-VR --
        // -- /SOLUTION: Gameplay-Movement-VR --

        // Return combined movement, prioritizing VR, then keyboard, then joystick
        return { x: vx || kx || jx, y: vy || ky || jy, t: vt || kt || jt };
    }

    // -- SOLUTION: Gameplay-Movement-Step --
    // Updates the user's position and orientation based on movement input and delta time
    function step(dt, mv) {
        const now = performance.now();
        const moveMagnitude = HYPOT(mv.x, mv.y);
        if(moveMagnitude > 0.1 && now - lastStepTime > stepInterval){
            playStepSound();
            lastStepTime = now;
        }
        user.yaw += mv.t * TURNS * dt; // Apply turning
        
        // Calculate forward and right vectors based on current yaw
        const cy = COS(user.yaw);
        const sy = SIN(user.yaw);
        T_V3_A[0] = -sy; T_V3_A[1] = 0; T_V3_A[2] = -cy; // 'f' vector
        T_V3_B[0] = cy;  T_V3_B[1] = 0; T_V3_B[2] = -sy;  // 'r' vector
        const sp = MOVES * dt;
        
        // Apply movement along forward and right vectors
        user.x += (T_V3_B[0] * mv.x + T_V3_A[0] * mv.y) * sp;
        user.z += (T_V3_B[2] * mv.x + T_V3_A[2] * mv.y) * sp;
    }
    // -- /SOLUTION: Gameplay-Movement-Step --
    // -- /MODULE: Gameplay-Movement --
    // -- /FEATURE: Gameplay --
    
    // -- FEATURE: Scene --
    // -- MODULE: Scene-Audio --
    // todo: implement stereo sources to get spatial audio (directional wind sound)
    let audioCtx = null;
    let lastStepTime = 0;
    const stepInterval = 500; // ms between walking sounds
    
    function initAudio(){
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (!window.windPlaying) { window.windPlaying = true; playWindSound(); }

    }
    // -- SOLUTION: Scene-Audio-Wind --
    function playWindSound(){}
    // -- /SOLUTION: Scene-Audio-Wind --
    // -- SOLUTION: Scene-Audio-Click --
    function playClickSound(){}
    // -- /SOLUTION: Scene-Audio-Click --
    // -- SOLUTION: Scene-Audio-Step --
    function playStepSound(){}
    // -- /SOLUTION: Scene-Audio-Step --
    // -- /MODULE: Scene-Audio --

    // -- MODULE: Scene-HUD --
    // --- Log and HUD UI State ---
    const LOG = [];
    const LOG_MAX = 200;
    let logScroll = 0;
    let logVisible = true;
    let hudVisible = true;

    // State for HUD interaction.
    let HUD_WH_world = M4(); // World matrix of the HUD quad
    let hoverBtn = null; // The button currently being hovered over

    function log(s) { LOG.push(s); if (LOG.length > LOG_MAX) LOG.shift(); }
    function logClear() { LOG.length = 0; log('log cleared'); }

    // UI button definitions. Each object defines a button's ID, position (in UV space), label, and click handler
    let uiEnterLabel = 'Enter VR';
    const UI_MAIN = [
        { id: 'reset', u0: 0.4, v0: 0.1, u1: 0.7, v1: 0.2, label: 'Reset', onClick: () => { playClickSound(); user.x = 0; user.z = 2; user.yaw = 0; user.pitch = 0; log('reset position'); } },
        { id: 'vr', u0: 0.4, v0: 0.3, u1: 0.7, v1: 0.4, label: () => uiEnterLabel, onClick: () => { playClickSound(); toggleXRFromUI(); } },
        { id: 'logtog', u0: 0.85, v0: 0.5, u1: 0.98, v1: 0.6 , label: 'LOG', onClick: () => { playClickSound(); logVisible = !logVisible; } },
        { id: 'logdn', u0: 0.85, v0: 0.8, u1: 0.98, v1: 0.9, label: 'Down', onClick: () => { playClickSound(); logScroll = MAX(0, logScroll - 1); } },
        { id: 'logup', u0: 0.85, v0: 0.7, u1: 0.98, v1: 0.8, label: 'Up', onClick: () => { playClickSound(); logScroll = MIN(MAX(0, LOG.length - 1), logScroll + 1); } },
        { id: 'hudx', u0: 0.8, v0: 0.04, u1: 0.98, v1: 0.2, label: 'Close       X', onClick: () => { playClickSound(); hudVisible = false; } }
    ];
    const UI_TAB = [
        { id: 'hudopen', u0: 0.4, v0: 0, u1: 0.6, v1: 0.12, label: 'HUD', onClick: () => { playClickSound(); hudVisible = true; } }
    ];

    // Returns the currently active set of UI buttons
    function currentUI() { return hudVisible ? UI_MAIN : UI_TAB; }

    // Returns the correct local transform for the HUD based on its visibility state
    function getHudTransform() {
        if (hudVisible) { // Centered panel
            return new DOMMatrix([1,0,0,0, 0,1,0,0, 0,0,1,0, 0, -0.05, -1.15, 1]).toFloat32Array();
        }
        // Top tab.
        return new DOMMatrix([1,0,0,0, 0,1,0,0, 0,0,1,0, 0, 0.5, -1.15, 1]).toFloat32Array();
    }

    // --- HUD Interaction Needs Input-ray ---
    function HUD_pick(WH, ray, uiSet) {
        const ui = uiSet || currentUI();
        const inv = INV(WH);
        const o = mulPoint(inv, ray.o); // Transform ray to HUD's local space
        const d = mulDir(inv, ray.d);
        const t = -o[2] / d[2]; // Intersect with the Z=0 plane
        if (t <= 0) return null;

        const x = o[0] + d[0] * t;
        const y = o[1] + d[1] * t;

        // Check if the hit is within the quad's bounds
        if (x < -0.26 || x > 0.26 || y < -0.15 || y > 0.15) return null;
        
        // Convert local coordinates to UV coordinates
        const u = (x + 0.26) / (0.26 * 2);
        const v = (0.15 - y) / (0.15 * 2);

        // Check against each button's UV bounds
        for (const b of ui) {
            if (u >= b.u0 && u <= b.u1 && v >= b.v0 && v <= b.v1) {
                return { id: b.id, u, v, button: b, t };
            }
        }
        return { id: null, u, v, button: null, t }; // Hit the panel but not a button
    }

    // --- HUD Drawing ---
    // Draws the entire HUD onto the 2D canvas
    function drawHUDCanvas(mode, hit, uiSet, dt) {
        const ui = uiSet || currentUI();
        hudCtx.clearRect(0, 0, hudCan.width, hudCan.height);

        if (!hudVisible) {
            // Draw the small "HUD" tab at the top of the screen
            const b = ui[0];
            const x = b.u0 * hudCan.width,
                  y = b.v0 * hudCan.height,
                  w = (b.u1 - b.u0) * hudCan.width,
                  h = (b.v1 - b.v0) * hudCan.height;
            const hov = hoverBtn && hoverBtn.id === 'hudopen';
            hudCtx.fillStyle = hov ? 'rgba(160,200,160,.28)' : 'rgba(120,160,120,.18)';
            hudCtx.strokeStyle = hov ? 'rgba(190,220,190,.95)' : 'rgba(160,200,160,.55)';
            hudCtx.lineWidth = 2;
            hudCtx.beginPath();
            hudCtx.roundRect(x, y, w, h, 10);
            hudCtx.fill();
            hudCtx.stroke();
            hudCtx.fillStyle = hov ? '#fff' : '#eef';
            hudCtx.font = '16px system-ui';
            hudCtx.textAlign = 'center';
            hudCtx.textBaseline = 'middle';
            hudCtx.fillText('HUD', x + w / 2, y + h / 2);
            hudCtx.textAlign = 'left';
            hudCtx.textBaseline = 'alphabetic';
        } else {
            // Draw the full HUD panel
            hudCtx.fillStyle = 'rgba(40,30,20,.90)';
            hudCtx.strokeStyle = 'rgba(255,255,255,.12)';
            hudCtx.lineWidth = 2;
            hudCtx.beginPath();
            hudCtx.roundRect(6, 6, hudCan.width - 12, hudCan.height - 12, 16);
            hudCtx.fill();
            hudCtx.stroke();

            // Header text
            hudCtx.fillStyle = '#9f9';
            hudCtx.font = '24px system-ui';
            hudCtx.fillText('HUD', 20, 34);
            hudCtx.fillStyle = '#fff';
            hudCtx.font = '16px system-ui';
            hudCtx.fillText(`Mode: ${mode}${isMobile ? ' (Touch)' : ''}`, 20, 60);
            hudCtx.fillText(`FPS: ${ROUND(1/dt)}`, 20, 80);
            hudCtx.fillText(`MS: ${dt.toFixed(3)}`, 100, 80);
            hudCtx.fillText(`Pos: (${user.x.toFixed(1)}, ${user.z.toFixed(1)})`, 100, 100);
            hudCtx.fillText(`Yaw: ${(user.yaw * 180 / PI | 0)}¬∞`, 20, 100);
            if (hit) { hudCtx.fillStyle = '#afa';
            hudCtx.fillText(`Hit @ ground: (${hit[0].toFixed(2)}, ${hit[2].toFixed(2)})`, 20, 120); }

            // Log box
            if (logVisible) {
                const x = 18,
                      y = 150,
                      w = hudCan.width - 120,
                      h = hudCan.height - 160;
                hudCtx.fillStyle = 'rgba(0,0,0,.35)';
                hudCtx.strokeStyle = 'rgba(255,255,255,.1)';
                hudCtx.beginPath();
                hudCtx.roundRect(x, y, w, h, 10);
                hudCtx.fill();
                hudCtx.stroke();
                hudCtx.save();
                hudCtx.beginPath();
                hudCtx.rect(x + 8, y + 8, w - 16, h - 16);
                hudCtx.clip();
                hudCtx.fillStyle = '#eee';
                hudCtx.font = '14px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
                const lines = LOG.slice(MAX(0, LOG.length - 8 - logScroll), LOG.length - logScroll);
                for (let i = 0; i < lines.length; i++)
                    hudCtx.fillText(lines[i], x + 12, y + 24 + i * 16);
                hudCtx.restore();
            }

            // Buttons
            for (const b of UI_MAIN) {
                const lab = (typeof b.label === 'function') ? b.label() : b.label;
                const x = b.u0 * hudCan.width,
                      y = b.v0 * hudCan.height,
                      w = (b.u1 - b.u0) * hudCan.width,
                      h = (b.v1 - b.v0) * hudCan.height;
                const hov = hoverBtn && hoverBtn.id === b.id;
                hudCtx.fillStyle = hov ? 'rgba(150,190,150,.25)' : 'rgba(120,160,120,.12)';
                hudCtx.strokeStyle = hov ? 'rgba(190,220,190,.9)' : 'rgba(160,200,160,.4)';
                hudCtx.lineWidth = 1;
                hudCtx.beginPath();
                hudCtx.roundRect(x, y, w, h, 8);
                hudCtx.fill(); hudCtx.stroke();
                hudCtx.fillStyle = hov ? '#fff' : '#eef';
                hudCtx.font = '18px system-ui';
                //hudCtx.textAlign = 'center';
                hudCtx.textBaseline = 'middle';
                //hudCtx.fillText(lab, x + w / 2, y + h / 2);
                //hudCtx.textAlign = 'left';
                // Center text vertically and with a slight left padding
                hudCtx.fillText(lab, x + 10, y + h * 0.5);
            }
        }

        // Upload the canvas content to the WebGL texture
        gl.bindTexture(gl.TEXTURE_2D, hudTex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, hudCan);
    }

    
    // --- HUD Shader ---
    // The HUD is a 2D canvas drawn in the DOM, then uploaded to a WebGL texture to be displayed on a 3D quad

    let hudTex = gl.createTexture();
    let hudCan = document.createElement('canvas');
    let hudCtx = hudCan.getContext('2d');
    hudCan.width = 640;
    hudCan.height = 320;

    gl.bindTexture(gl.TEXTURE_2D, hudTex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // Simple textured quad shader for the HUD
    const vsH = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 p;
    layout(location=1) in vec2 uv;
    uniform mat4 M, V, P;
    out vec2 U;
    void main(){
        U = uv;
        gl_Position = P * V * M * vec4(p, 1.0);
    }`;
    const fsH = `#version 300 es
    precision highp float;
    #define UNIFORM uniform
    in vec2 U;
    UNIFORM sampler2D T;
    out vec4 o;
    void main(){
        vec4 c = texture(T, U);
        if(c.a < 0.01) discard; // Discard fully transparent pixels.
        o = c;
    }`;
    const PH = prog(vsH, fsH);
    const uMH = gl.getUniformLocation(PH, 'M'),
          uVH = gl.getUniformLocation(PH, 'V'),
          uPH = gl.getUniformLocation(PH, 'P'),
          uT = gl.getUniformLocation(PH, 'T');

    const vboH = gl.createBuffer(), vaoH = gl.createVertexArray();
    gl.bindVertexArray(vaoH);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboH);
    // Vertex data for the HUD quad (position and UV coordinates).
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-0.26,0.15,0, 0,1,  0.26,0.15,0, 1,1,  0.26,-0.15,0, 1,0,  -0.26,0.15,0, 0,1,  0.26,-0.15,0, 1,0,  -0.26,-0.15,0, 0,0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0); 
    gl.vertexAttribPointer(0, 3, 
    gl.FLOAT, false, 20, 0);
    gl.enableVertexAttribArray(1); 
    gl.vertexAttribPointer(1, 2, 
    gl.FLOAT, false, 20, 12);

    // -- /MODULE: Scene-HUD --
    // -- MODULE: Scene-Sky --
    // -- /MODULE: Scene-Sky --
    // -- MODULE: Scene-Ground --
    // --- Grid Shader ---
    // A simple shader to draw a grid on the ground plane
    const vsG = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 p;
    uniform mat4 M, V, P;
    out vec3 w; // Pass world position to fragment shader.
    void main(){
        w = (M * vec4(p, 1.0)).xyz;
        gl_Position = P * V * vec4(w, 1.0);
    }`;
    const fsG = `#version 300 es
    precision highp float;
    in vec3 w;
    out vec4 o;
    void main(){
        float c = 2.0; // Grid cell size.
        // Draw lines using fract() and step().
        float l = step(abs(fract(w.x/c) - 0.5), 0.01) + step(abs(fract(w.z/c) - 0.5), 0.01);
        float g = clamp(l, 0.0, 1.0);
        // Fade to a darker color in the distance.
        vec3 b = mix(vec3(0.04), vec3(0.08), smoothstep(0.0, 20.0, length(w.xz)));
        o = vec4(b + g * vec3(0.2, 1.0, 0.2) * 0.6, 1.0);
    }`;

    const PG = prog(vsG, fsG);
    const uM = gl.getUniformLocation(PG, 'M');
    const uV = gl.getUniformLocation(PG, 'V');
    const uP = gl.getUniformLocation(PG, 'P');
    const vbo = gl.createBuffer();
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    // A large quad to serve as the ground plane.
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1e3,0,-1e3, 1e3,0,-1e3, 1e3,0,1e3, -1e3,0,-1e3, 1e3,0,1e3, -1e3,0,1e3]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    // -- /MODULE: Scene-Ground --
    // -- MODULE: Scene-Grass --
    
    // -- /MODULE: Scene-Grass --
    // -- MODULE: Scene-Plant --
    
    // -- /MODULE: Scene-Plant --
    
    // -- MODULE: Scene-Reticle --
    const vsR = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 p;
    uniform mat4 M, V, P;
    out vec2 uv;
    void main(){
        uv = p * 0.5 + 0.5;
        gl_Position = P * V * M * vec4(p.x, 0.0, p.y, 1.0);
    }`;
    const fsR = `#version 300 es
    precision highp float;
    in vec2 uv;
    out vec4 o;
    void main(){
        float d = distance(uv, vec2(0.5));
        float ring = smoothstep(0.5, 0.4, d) - smoothstep(0.4, 0.3, d);
        o = vec4(0.9, 1.0, 0.9, ring * 0.95);
        if(o.a < 0.02) discard;
    }`;
    const PR = prog(vsR, fsR);
    const uMR = gl.getUniformLocation(PR, 'M'), uVR = gl.getUniformLocation(PR, 'V'), uPR = gl.getUniformLocation(PR, 'P');
    const vboR = gl.createBuffer(), vaoR = gl.createVertexArray();
    gl.bindVertexArray(vaoR);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboR);
    gl.bufferData(gl.ARRAY_BUFFER, new F32([-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    // -- /MODULE: Scene-Reticle --

    // -- MODULE: Scene-VR --
    // -- /MODULE: Scene-VR --

    // -- /FEATURE: Scene --
    
    // -- CORE: render --
    // --- Main Render Loop (Desktop) ---

    function loop(t) {
        // Calculate delta time
        const dt = ((t - last) / 1000) || 0;
        last = t;

        // Update user position

        // Update camera matrices
        buildViewProj();

        // --- Rendering ---
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Render Sky
        
        // Noise texture for clouds

        // Render Grid
        gl.useProgram(PG);
        gl.bindVertexArray(vao);
        gl.uniformMatrix4fv(uM, false, M);
        gl.uniformMatrix4fv(uV, false, V);
        gl.uniformMatrix4fv(uP, false, P);
        if (beastMode===true){
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.FRONT)}
        else {gl.disable(gl.CULL_FACE);};
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Render Grass in multiple passes for density and LOD
        
        // Render L-System Plants
        
        // Render Reticle if there's a ground hit
         if (lastHit) {
            const T = translateScale(lastHit[0], 0.001, lastHit[2], 0.15, 1, 0.15);
            gl.useProgram(PR);
            gl.bindVertexArray(vaoR);
            gl.uniformMatrix4fv(uMR, false, T);
            gl.uniformMatrix4fv(uVR, false, V);
            gl.uniformMatrix4fv(uPR, false, P);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.DEPTH_TEST);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
        }


        // Render HUD
        const T = getHudTransform();
        const W = INV(V); // Get world-from-view matrix
        const WH = new DOMMatrix(W).multiply(new DOMMatrix(T)).toFloat32Array(); // Combine to get HUD's world matri
        HUD_WH_world = WH;
        hoverBtn = null;

        // Check for hover state if not in mouse-look mode
        if (input.look.id === null) {
            const r = rayFromScreen(input.pointer.x, input.pointer.y);
            const h = HUD_pick(WH, r, currentUI());
            if (h && h.button) hoverBtn = h.button;
        }

        updHUD('Desktop', lastHit, currentUI(), dt); // Redraw and upload HUD texture

        gl.useProgram(PH);
        gl.bindVertexArray(vaoH);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, hudTex);
        gl.uniform1i(uT, 0);
        gl.uniformMatrix4fv(uMH, false, WH);
        gl.uniformMatrix4fv(uVH, false, V);
        gl.uniformMatrix4fv(uPH, false, P);
        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);

        requestAnimationFrame(loop);
    }

    // Helper to update the HUD canvas content
    function updHUD(mode, hit, uiSet, dt) {
        drawHUDCanvas(mode, hit, uiSet, dt);
    }

    // Helper to submit a grass draw call

    // Computes the view and projection matrices for desktop mode
    function buildViewProj() {
        const cy = COS(user.yaw),
              sy = SIN(user.yaw);
        const cp = COS(user.pitch),
              sp = SIN(user.pitch);
        const eye = [user.x, user.y, user.z];
        const center = [user.x - sy * cp, user.y - sp, user.z - cy * cp];
        LOOKAT(V, eye, center, [0, 1, 0]);
        PERSP(P, 60, canvas.width / canvas.height, 0.01, 1e3);
        PV = MULTMAT4(M4(), P, V);
        invPV = INV(PV);
    }
    // -- /CORE: Render --

    // -- FEATURE: VR --
    
    // -- /FEATURE: VR --
    
    // -- FEATURE: CORE --
    // --- Application Entry Point ---
    (function main() {
        requestAnimationFrame(loop);
        log(`Welcome Catch the black cat!`);
        log('close HUD using Close button X (H & Esc)');
        if (!isMobile) log('Use (WASD) to move and (Q & E) to rotate');
        if (isMobile) log('Use left joystick to move and right joystick to rotate');
        log('Use touch-drag to Look around');
    })();
    
    // -- /FEATURE: CORE --
    </script>
</body>
</html>
